#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

from grako.parsing import graken, Parser
from grako.util import re, RE_FLAGS, generic_main  # noqa


__version__ = (2016, 6, 29, 1, 23, 27, 2)

__all__ = [
    'SqlParser',
    'SqlSemantics',
    'main'
]

KEYWORDS = set([])


class SqlParser(Parser):
    def __init__(self,
                 whitespace=None,
                 nameguard=None,
                 comments_re=None,
                 eol_comments_re=None,
                 ignorecase=True,
                 left_recursion=True,
                 keywords=KEYWORDS,
                 namechars='',
                 **kwargs):
        super(SqlParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            keywords=keywords,
            namechars=namechars,
            **kwargs
        )

    @graken()
    def _start_(self):
        self._direct_sql_statement_()

    @graken()
    def _CHARACTER_(self):
        with self._choice():
            with self._option():
                self._LETTER_()
            with self._option():
                self._DIGIT_()
            with self._option():
                self._SPECIAL_CHARACTER_()
            self._error('no available options')

    @graken()
    def _LETTER_(self):
        self._pattern(r'[A-Za-z]')

    @graken()
    def _DIGIT_(self):
        self._pattern(r'\d')

    @graken()
    def _SPECIAL_CHARACTER_(self):
        with self._choice():
            with self._option():
                self._SPACE_()
            with self._option():
                self._token('"')
            with self._option():
                self._token("'")
            with self._option():
                self._token('/')
            with self._option():
                self._pattern(r'[%&()*+,.:;<>=?_|-]')
            self._error('expecting one of: " \' / [%&()*+,.:;<>=?_|-]')

    @graken()
    def _SPACE_(self):
        self._pattern(r'\s')

    @graken()
    def _REGULAR_IDENTIFIER_(self):
        self._IDENTIFIER_BODY_()

    @graken()
    def _IDENTIFIER_BODY_(self):
        self._IDENTIFIER_START_()
        with self._optional():

            def block0():
                with self._choice():
                    with self._option():
                        self._token('_')
                    with self._option():
                        self._IDENTIFIER_PART_()
                    self._error('expecting one of: _')
            self._positive_closure(block0)

    @graken()
    def _IDENTIFIER_START_(self):
        self._LETTER_()

    @graken()
    def _IDENTIFIER_PART_(self):
        with self._choice():
            with self._option():
                self._IDENTIFIER_START_()
            with self._option():
                self._DIGIT_()
            self._error('no available options')

    @graken()
    def _unsigned_numeric_literal_(self):
        with self._choice():
            with self._option():
                self._exact_numeric_literal_()
            with self._option():
                self._approximate_numeric_literal_()
            self._error('no available options')

    @graken()
    def _exact_numeric_literal_(self):
        with self._choice():
            with self._option():
                self._unsigned_integer_()
                with self._optional():
                    self._token('.')
                    with self._optional():
                        self._unsigned_integer_()
            with self._option():
                self._token('.')
                self._unsigned_integer_()
            self._error('no available options')

    @graken()
    def _unsigned_integer_(self):

        def block0():
            self._DIGIT_()
        self._positive_closure(block0)

    @graken()
    def _approximate_numeric_literal_(self):
        self._mantissa_()
        self._token('E')
        self._exponent_()

    @graken()
    def _mantissa_(self):
        self._exact_numeric_literal_()

    @graken()
    def _exponent_(self):
        self._signed_integer_()

    @graken()
    def _signed_integer_(self):
        with self._optional():
            self._sign_()
        self._unsigned_integer_()

    @graken()
    def _sign_(self):
        with self._choice():
            with self._option():
                self._token('+')
            with self._option():
                self._token('-')
            self._error('expecting one of: + -')

    @graken()
    def _national_character_string_literal_(self):
        self._token('N')
        self._token("'")
        with self._optional():

            def block0():
                self._character_representation_()
            self._positive_closure(block0)
        self._token("'")
        with self._optional():

            def block1():

                def block2():
                    self._separator_()
                self._closure(block2)
                self._token("'")
                with self._optional():

                    def block3():
                        self._character_representation_()
                    self._positive_closure(block3)
                self._token("'")
            self._positive_closure(block1)

    @graken()
    def _character_representation_(self):
        with self._choice():
            with self._option():
                self._nonquote_character_()
            with self._option():
                self._quote_symbol_()
            self._error('no available options')

    @graken()
    def _nonquote_character_(self):
        self._LETTER_()

    @graken()
    def _quote_symbol_(self):
        self._token("''")

    @graken()
    def _separator_(self):

        def block0():
            with self._choice():
                with self._option():
                    self._comment_()
                with self._option():
                    self._SPACE_()
                with self._option():
                    self._NEWLINE_()
                self._error('no available options')
        self._closure(block0)

    @graken()
    def _comment_(self):
        self._comment_introducer_()
        with self._optional():

            def block0():
                self._comment_character_()
            self._positive_closure(block0)
        self._NEWLINE_()

    @graken()
    def _comment_introducer_(self):
        self._token('--')
        with self._optional():

            def block0():
                self._token('-')
            self._positive_closure(block0)

    @graken()
    def _comment_character_(self):
        with self._choice():
            with self._option():
                self._nonquote_character_()
            with self._option():
                self._token("'")
            self._error("expecting one of: '")

    @graken()
    def _NEWLINE_(self):
        self._pattern(r'[\r\n]')

    @graken()
    def _bit_string_literal_(self):
        self._token('B')
        self._token("'")
        with self._optional():

            def block0():
                self._bit_()
            self._closure(block0)
        self._token("'")
        with self._optional():

            def block1():

                def block2():
                    self._separator_()
                self._closure(block2)
                self._token("'")
                with self._optional():

                    def block3():
                        self._bit_()
                    self._closure(block3)
                self._token("'")
            self._positive_closure(block1)

    @graken()
    def _bit_(self):
        self._pattern(r'[01]+')

    @graken()
    def _hex_string_literal_(self):
        self._token('X')
        self._token("'")
        with self._optional():

            def block0():
                self._hexit_()
            self._closure(block0)
        self._token("'")
        with self._optional():

            def block1():

                def block2():
                    self._separator_()
                self._closure(block2)
                self._token("'")
                with self._optional():

                    def block3():
                        self._hexit_()
                    self._closure(block3)
                self._token("'")
            self._positive_closure(block1)

    @graken()
    def _hexit_(self):
        self._pattern(r'[\dA-Fa-f]+')

    @graken()
    def _character_string_literal_(self):
        with self._optional():
            self._introducer_()
            self._character_set_name_()
        self._token("'")
        with self._optional():

            def block0():
                self._character_representation_()
            self._positive_closure(block0)
        self._token("'")
        with self._optional():

            def block1():

                def block2():
                    self._separator_()
                self._closure(block2)
                self._token("'")
                with self._optional():

                    def block3():
                        self._character_representation_()
                    self._positive_closure(block3)
                self._token("'")
            self._positive_closure(block1)

    @graken()
    def _introducer_(self):
        self._token('_')

    @graken()
    def _character_set_name_(self):
        with self._optional():
            self._schema_name_()
            self._token('.')
        self._IDENTIFIER_BODY_()

    @graken()
    def _schema_name_(self):
        with self._optional():
            self._catalog_name_()
            self._token('.')
        self._unqualified_schema_name_()

    @graken()
    def _catalog_name_(self):
        self._IDENTIFIER_()

    @graken()
    def _IDENTIFIER_(self):
        with self._optional():
            self._introducer_()
            self._character_set_name_()
        self._actual_IDENTIFIER_()

    @graken()
    def _actual_IDENTIFIER_(self):
        with self._choice():
            with self._option():
                self._REGULAR_IDENTIFIER_()
            with self._option():
                self._delimited_IDENTIFIER_()
            self._error('no available options')

    @graken()
    def _delimited_IDENTIFIER_(self):
        self._token('"')
        self._delimited_IDENTIFIER_BODY_()
        self._token('"')

    @graken()
    def _delimited_IDENTIFIER_BODY_(self):

        def block0():
            self._delimited_IDENTIFIER_PART_()
        self._closure(block0)

    @graken()
    def _delimited_IDENTIFIER_PART_(self):
        with self._choice():
            with self._option():
                self._LETTER_()
            with self._option():
                self._doublequote_symbol_()
            self._error('no available options')

    @graken()
    def _doublequote_symbol_(self):
        self._token('""')

    @graken()
    def _unqualified_schema_name_(self):
        self._IDENTIFIER_()

    @graken()
    def _date_string_(self):
        self._token("'")
        self._date_value_()
        self._token("'")

    @graken()
    def _date_value_(self):
        self._years_value_()
        self._token('-')
        self._months_value_()
        self._token('-')
        self._days_value_()

    @graken()
    def _years_value_(self):
        self._datetime_value_()

    @graken()
    def _datetime_value_(self):
        self._unsigned_integer_()

    @graken()
    def _months_value_(self):
        self._datetime_value_()

    @graken()
    def _days_value_(self):
        self._datetime_value_()

    @graken()
    def _time_string_(self):
        self._token("'")
        self._time_value_()
        with self._optional():
            self._time_zone_interval_()
        self._token("'")

    @graken()
    def _time_value_(self):
        self._hours_value_()
        self._token(':')
        self._minutes_value_()
        self._token(':')
        self._seconds_value_()

    @graken()
    def _hours_value_(self):
        self._datetime_value_()

    @graken()
    def _minutes_value_(self):
        self._datetime_value_()

    @graken()
    def _seconds_value_(self):
        self._seconds_integer_value_()
        with self._optional():
            self._token('.')
            with self._optional():
                self._seconds_fraction_()

    @graken()
    def _seconds_integer_value_(self):
        self._unsigned_integer_()

    @graken()
    def _seconds_fraction_(self):
        self._unsigned_integer_()

    @graken()
    def _time_zone_interval_(self):
        self._sign_()
        self._hours_value_()
        self._token(':')
        self._minutes_value_()

    @graken()
    def _timestamp_string_(self):
        self._token("'")
        self._date_value_()
        self._SPACE_()
        self._time_value_()
        with self._optional():
            self._time_zone_interval_()
        self._token("'")

    @graken()
    def _interval_string_(self):
        self._token("'")

        def block0():
            with self._choice():
                with self._option():
                    self._year_month_literal_()
                with self._option():
                    self._day_time_literal_()
                self._error('no available options')
        self._closure(block0)
        self._token("'")

    @graken()
    def _year_month_literal_(self):
        with self._choice():
            with self._option():
                self._years_value_()
            with self._option():
                with self._optional():
                    self._years_value_()
                    self._token('-')
                self._months_value_()
            self._error('no available options')

    @graken()
    def _day_time_literal_(self):
        with self._choice():
            with self._option():
                self._day_time_interval_()
            with self._option():
                self._time_interval_()
            self._error('no available options')

    @graken()
    def _day_time_interval_(self):
        self._days_value_()
        with self._optional():
            self._SPACE_()
            self._hours_value_()
            with self._optional():
                self._token(':')
                self._minutes_value_()
                with self._optional():
                    self._token(':')
                    self._seconds_value_()

    @graken()
    def _time_interval_(self):
        with self._choice():
            with self._option():
                self._hours_value_()
                with self._optional():
                    self._token(':')
                    self._minutes_value_()
                    with self._optional():
                        self._token(':')
                        self._seconds_value_()
            with self._option():
                self._minutes_value_()
                with self._optional():
                    self._token(':')
                    self._seconds_value_()
            with self._option():
                self._seconds_value_()
            self._error('no available options')

    @graken()
    def _authorization_IDENTIFIER_(self):
        self._IDENTIFIER_()

    @graken()
    def _temporary_table_declaration_(self):
        self._token('DECLARE')
        self._token('LOCAL')
        self._token('TEMPORARY')
        self._token('TABLE')
        self._qualified_local_table_name_()
        self._table_element_list_()
        with self._optional():
            self._token('ON')
            self._token('COMMIT')

            def block0():
                with self._choice():
                    with self._option():
                        self._token('PRESERVE')
                    with self._option():
                        self._token('DELETE')
                    self._error('expecting one of: DELETE PRESERVE')
            self._closure(block0)
            self._token('ROWS')

    @graken()
    def _qualified_local_table_name_(self):
        self._token('MODULE')
        self._token('.')
        self._local_table_name_()

    @graken()
    def _local_table_name_(self):
        self._qualified_IDENTIFIER_()

    @graken()
    def _qualified_IDENTIFIER_(self):
        self._IDENTIFIER_()

    @graken()
    def _table_element_list_(self):
        self._token('(')
        self._table_element_()
        with self._optional():

            def block0():
                self._token(',')
                self._table_element_()
            self._positive_closure(block0)
        self._token(')')

    @graken()
    def _table_element_(self):
        with self._choice():
            with self._option():
                self._column_definition_()
            with self._option():
                self._table_constraint_definition_()
            self._error('no available options')

    @graken()
    def _column_definition_(self):
        self._column_name_()

        def block0():
            with self._choice():
                with self._option():
                    self._data_type_()
                with self._option():
                    self._domain_name_()
                self._error('no available options')
        self._closure(block0)
        with self._optional():
            self._default_clause_()
        with self._optional():

            def block2():
                self._column_constraint_definition_()
            self._positive_closure(block2)
        with self._optional():
            self._collate_clause_()

    @graken()
    def _column_name_(self):
        self._IDENTIFIER_()

    @graken()
    def _data_type_(self):
        with self._choice():
            with self._option():
                self._character_string_type_()
                with self._optional():
                    self._token('CHARACTER')
                    self._token('SET')
                    self._character_set_name_()
            with self._option():
                self._national_character_string_type_()
            with self._option():
                self._bit_string_type_()
            with self._option():
                self._numeric_type_()
            with self._option():
                self._datetime_type_()
            with self._option():
                self._interval_type_()
            self._error('no available options')

    @graken()
    def _character_string_type_(self):
        with self._choice():
            with self._option():
                self._token('CHARACTER')
                with self._optional():
                    self._token('(')
                    self._length_()
                    self._token(')')
            with self._option():
                self._token('CHAR')
                with self._optional():
                    self._token('(')
                    self._length_()
                    self._token(')')
            with self._option():
                self._token('CHARACTER')
                self._token('VARYING')
                with self._optional():
                    self._token('(')
                    self._length_()
                    self._token(')')
            with self._option():
                self._token('CHAR')
                self._token('VARYING')
                with self._optional():
                    self._token('(')
                    self._length_()
                    self._token(')')
            with self._option():
                self._token('VARCHAR')
                with self._optional():
                    self._token('(')
                    self._length_()
                    self._token(')')
            self._error('expecting one of: CHAR CHARACTER VARCHAR')

    @graken()
    def _length_(self):
        self._unsigned_integer_()

    @graken()
    def _national_character_string_type_(self):
        with self._choice():
            with self._option():
                self._token('NATIONAL')
                self._token('CHARACTER')
                with self._optional():
                    self._token('(')
                    self._length_()
                    self._token(')')
            with self._option():
                self._token('NATIONAL')
                self._token('CHAR')
                with self._optional():
                    self._token('(')
                    self._length_()
                    self._token(')')
            with self._option():
                self._token('NCHAR')
                with self._optional():
                    self._token('(')
                    self._length_()
                    self._token(')')
            with self._option():
                self._token('NATIONAL')
                self._token('CHARACTER')
                self._token('VARYING')
                with self._optional():
                    self._token('(')
                    self._length_()
                    self._token(')')
            with self._option():
                self._token('NATIONAL')
                self._token('CHAR')
                self._token('VARYING')
                with self._optional():
                    self._token('(')
                    self._length_()
                    self._token(')')
            with self._option():
                self._token('NCHAR')
                self._token('VARYING')
                with self._optional():
                    self._token('(')
                    self._length_()
                    self._token(')')
            self._error('expecting one of: NATIONAL NCHAR')

    @graken()
    def _bit_string_type_(self):
        with self._choice():
            with self._option():
                self._token('BIT')
                with self._optional():
                    self._token('(')
                    self._length_()
                    self._token(')')
            with self._option():
                self._token('BIT')
                self._token('VARYING')
                with self._optional():
                    self._token('(')
                    self._length_()
                    self._token(')')
            self._error('expecting one of: BIT')

    @graken()
    def _numeric_type_(self):
        with self._choice():
            with self._option():
                self._exact_numeric_type_()
            with self._option():
                self._approximate_numeric_type_()
            self._error('no available options')

    @graken()
    def _exact_numeric_type_(self):
        with self._choice():
            with self._option():
                self._token('NUMERIC')
                with self._optional():
                    self._token('(')
                    self._precision_()
                    with self._optional():
                        self._token(',')
                        self._scale_()
                    self._token(')')
            with self._option():
                self._token('DECIMAL')
                with self._optional():
                    self._token('(')
                    self._precision_()
                    with self._optional():
                        self._token(',')
                        self._scale_()
                    self._token(')')
            with self._option():
                self._token('DEC')
                with self._optional():
                    self._token('(')
                    self._precision_()
                    with self._optional():
                        self._token(',')
                        self._scale_()
                    self._token(')')
            with self._option():
                self._token('INTEGER')
            with self._option():
                self._token('INT')
            with self._option():
                self._token('SMALLINT')
            self._error('expecting one of: DEC DECIMAL INT INTEGER NUMERIC SMALLINT')

    @graken()
    def _precision_(self):
        self._unsigned_integer_()

    @graken()
    def _scale_(self):
        self._unsigned_integer_()

    @graken()
    def _approximate_numeric_type_(self):
        with self._choice():
            with self._option():
                self._token('FLOAT')
                with self._optional():
                    self._token('(')
                    self._precision_()
                    self._token(')')
            with self._option():
                self._token('REAL')
            with self._option():
                self._token('DOUBLE')
                self._token('PRECISION')
            self._error('expecting one of: DOUBLE FLOAT REAL')

    @graken()
    def _datetime_type_(self):
        with self._choice():
            with self._option():
                self._token('DATE')
            with self._option():
                self._token('TIME')
                with self._optional():
                    self._token('(')
                    self._time_precision_()
                    self._token(')')
                with self._optional():
                    self._token('WITH')
                    self._token('TIME')
                    self._token('ZONE')
            with self._option():
                self._token('TIMESTAMP')
                with self._optional():
                    self._token('(')
                    self._timestamp_precision_()
                    self._token(')')
                with self._optional():
                    self._token('WITH')
                    self._token('TIME')
                    self._token('ZONE')
            self._error('expecting one of: DATE TIME TIMESTAMP')

    @graken()
    def _time_precision_(self):
        self._time_fractional_seconds_precision_()

    @graken()
    def _time_fractional_seconds_precision_(self):
        self._unsigned_integer_()

    @graken()
    def _timestamp_precision_(self):
        self._time_fractional_seconds_precision_()

    @graken()
    def _interval_type_(self):
        self._token('INTERVAL')
        self._interval_qualifier_()

    @graken()
    def _interval_qualifier_(self):
        with self._choice():
            with self._option():
                self._start_field_()
                self._token('TO')
                self._end_field_()
            with self._option():
                self._single_datetime_field_()
            self._error('no available options')

    @graken()
    def _start_field_(self):
        self._non_second_datetime_field_()
        with self._optional():
            self._token('(')
            self._interval_leading_field_precision_()
            self._token(')')

    @graken()
    def _non_second_datetime_field_(self):
        with self._choice():
            with self._option():
                self._token('YEAR')
            with self._option():
                self._token('MONTH')
            with self._option():
                self._token('DAY')
            with self._option():
                self._token('HOUR')
            with self._option():
                self._token('MINUTE')
            self._error('expecting one of: DAY HOUR MINUTE MONTH YEAR')

    @graken()
    def _interval_leading_field_precision_(self):
        self._unsigned_integer_()

    @graken()
    def _end_field_(self):
        with self._choice():
            with self._option():
                self._non_second_datetime_field_()
            with self._option():
                self._token('SECOND')
                with self._optional():
                    self._token('(')
                    self._interval_fractional_seconds_precision_()
                    self._token(')')
            self._error('expecting one of: SECOND')

    @graken()
    def _interval_fractional_seconds_precision_(self):
        self._unsigned_integer_()

    @graken()
    def _single_datetime_field_(self):
        with self._choice():
            with self._option():
                self._non_second_datetime_field_()
                with self._optional():
                    self._token('(')
                    self._interval_leading_field_precision_()
                    self._token(')')
            with self._option():
                self._token('SECOND')
                with self._optional():
                    self._token('(')
                    self._interval_leading_field_precision_()
                    with self._optional():
                        self._token(',')
                        self._token('(')
                        self._interval_fractional_seconds_precision_()
                    self._token(')')
            self._error('expecting one of: SECOND')

    @graken()
    def _domain_name_(self):
        self._qualified_name_()

    @graken()
    def _qualified_name_(self):
        with self._optional():
            self._schema_name_()
            self._token('.')
        self._qualified_IDENTIFIER_()

    @graken()
    def _default_clause_(self):
        self._token('DEFAULT')
        self._default_option_()

    @graken()
    def _default_option_(self):
        with self._choice():
            with self._option():
                self._literal_()
            with self._option():
                self._datetime_value_function_()
            with self._option():
                self._token('USER')
            with self._option():
                self._token('CURRENT_USER')
            with self._option():
                self._token('SESSION_USER')
            with self._option():
                self._token('SYSTEM_USER')
            with self._option():
                self._token('NULL')
            self._error('expecting one of: CURRENT_USER NULL SESSION_USER SYSTEM_USER USER')

    @graken()
    def _literal_(self):
        with self._choice():
            with self._option():
                self._signed_numeric_literal_()
            with self._option():
                self._general_literal_()
            self._error('no available options')

    @graken()
    def _signed_numeric_literal_(self):
        with self._optional():
            self._sign_()
        self._unsigned_numeric_literal_()

    @graken()
    def _general_literal_(self):
        with self._choice():
            with self._option():
                self._character_string_literal_()
            with self._option():
                self._national_character_string_literal_()
            with self._option():
                self._bit_string_literal_()
            with self._option():
                self._hex_string_literal_()
            with self._option():
                self._datetime_literal_()
            with self._option():
                self._interval_literal_()
            self._error('no available options')

    @graken()
    def _datetime_literal_(self):
        with self._choice():
            with self._option():
                self._date_literal_()
            with self._option():
                self._time_literal_()
            with self._option():
                self._timestamp_literal_()
            self._error('no available options')

    @graken()
    def _date_literal_(self):
        self._token('DATE')
        self._date_string_()

    @graken()
    def _time_literal_(self):
        self._token('TIME')
        self._time_string_()

    @graken()
    def _timestamp_literal_(self):
        self._token('TIMESTAMP')
        self._timestamp_string_()

    @graken()
    def _interval_literal_(self):
        self._token('INTERVAL')
        with self._optional():
            self._sign_()
        self._interval_string_()
        self._interval_qualifier_()

    @graken()
    def _datetime_value_function_(self):
        with self._choice():
            with self._option():
                self._current_date_value_function_()
            with self._option():
                self._current_time_value_function_()
            with self._option():
                self._current_timestamp_value_function_()
            self._error('no available options')

    @graken()
    def _current_date_value_function_(self):
        self._token('CURRENT_DATE')

    @graken()
    def _current_time_value_function_(self):
        self._token('CURRENT_TIME')
        with self._optional():
            self._token('(')
            self._time_precision_()
            self._token(')')

    @graken()
    def _current_timestamp_value_function_(self):
        self._token('CURRENT_TIMESTAMP')
        with self._optional():
            self._token('(')
            self._timestamp_precision_()
            self._token(')')

    @graken()
    def _column_constraint_definition_(self):
        with self._optional():
            self._constraint_name_definition_()
        self._column_constraint_()
        with self._optional():
            self._constraint_attributes_()

    @graken()
    def _constraint_name_definition_(self):
        self._token('CONSTRAINT')
        self._constraint_name_()

    @graken()
    def _constraint_name_(self):
        self._qualified_name_()

    @graken()
    def _column_constraint_(self):
        with self._choice():
            with self._option():
                self._token('NOT')
                self._token('NULL')
            with self._option():
                self._unique_specification_()
            with self._option():
                self._references_specification_()
            with self._option():
                self._check_constraint_definition_()
            self._error('expecting one of: NOT')

    @graken()
    def _unique_specification_(self):
        with self._choice():
            with self._option():
                self._token('UNIQUE')
            with self._option():
                self._token('PRIMARY')
                self._token('KEY')
            self._error('expecting one of: PRIMARY UNIQUE')

    @graken()
    def _references_specification_(self):
        self._token('REFERENCES')
        self._referenced_table_and_columns_()
        with self._optional():
            self._token('MATCH')
            self._match_type_()
        with self._optional():
            self._referential_triggered_action_()

    @graken()
    def _referenced_table_and_columns_(self):
        self._table_name_()
        with self._optional():
            self._token('(')
            self._reference_column_list_()
            self._token(')')

    @graken()
    def _table_name_(self):
        with self._choice():
            with self._option():
                self._qualified_name_()
            with self._option():
                self._qualified_local_table_name_()
            self._error('no available options')

    @graken()
    def _reference_column_list_(self):
        self._column_name_list_()

    @graken()
    def _column_name_list_(self):
        self._column_name_()
        with self._optional():

            def block0():
                self._token(',')
                self._column_name_()
            self._positive_closure(block0)

    @graken()
    def _match_type_(self):
        with self._choice():
            with self._option():
                self._token('FULL')
            with self._option():
                self._token('PARTIAL')
            self._error('expecting one of: FULL PARTIAL')

    @graken()
    def _referential_triggered_action_(self):
        with self._choice():
            with self._option():
                self._update_rule_()
                with self._optional():
                    self._delete_rule_()
            with self._option():
                self._delete_rule_()
                with self._optional():
                    self._update_rule_()
            self._error('no available options')

    @graken()
    def _update_rule_(self):
        self._token('ON')
        self._token('UPDATE')
        self._referential_action_()

    @graken()
    def _referential_action_(self):
        with self._choice():
            with self._option():
                self._token('CASCADE')
            with self._option():
                self._token('SET')
                self._token('NULL')
            with self._option():
                self._token('SET')
                self._token('DEFAULT')
            with self._option():
                self._token('NO')
                self._token('ACTION')
            self._error('expecting one of: CASCADE NO SET')

    @graken()
    def _delete_rule_(self):
        self._token('ON')
        self._token('DELETE')
        self._referential_action_()

    @graken()
    def _check_constraint_definition_(self):
        self._token('CHECK')
        self._token('(')
        self._search_condition_()
        self._token(')')

    @graken()
    def _search_condition_(self):
        with self._choice():
            with self._option():
                self._boolean_term_()
            with self._option():
                self._search_condition_()
                self._token('OR')
                self._boolean_term_()
            self._error('no available options')

    @graken()
    def _boolean_term_(self):
        with self._choice():
            with self._option():
                self._boolean_factor_()
            with self._option():
                self._boolean_term_()
                self._token('AND')
                self._boolean_factor_()
            self._error('no available options')

    @graken()
    def _boolean_factor_(self):
        with self._optional():
            self._token('NOT')
        self._boolean_test_()

    @graken()
    def _boolean_test_(self):
        self._boolean_primary_()
        with self._optional():
            self._token('IS')
            with self._optional():
                self._token('NOT')
            self._truth_value_()

    @graken()
    def _boolean_primary_(self):
        with self._choice():
            with self._option():
                self._predicate_()
            with self._option():
                self._token('(')
                self._search_condition_()
                self._token(')')
            self._error('no available options')

    @graken()
    def _predicate_(self):
        with self._choice():
            with self._option():
                self._comparison_predicate_()
            with self._option():
                self._between_predicate_()
            with self._option():
                self._in_predicate_()
            with self._option():
                self._like_predicate_()
            with self._option():
                self._null_predicate_()
            with self._option():
                self._quantified_comparison_predicate_()
            with self._option():
                self._exists_predicate_()
            with self._option():
                self._match_predicate_()
            with self._option():
                self._overlaps_predicate_()
            self._error('no available options')

    @graken()
    def _comparison_predicate_(self):
        self._row_value_constructor_()
        self._comp_op_()
        self._row_value_constructor_()

    @graken()
    def _row_value_constructor_(self):
        with self._choice():
            with self._option():
                self._row_value_constructor_element_()
            with self._option():
                self._token('(')
                self._row_value_constructor_list_()
                self._token(')')
            with self._option():
                self._row_subquery_()
            self._error('no available options')

    @graken()
    def _row_value_constructor_element_(self):
        with self._choice():
            with self._option():
                self._value_expression_()
            with self._option():
                self._null_specification_()
            with self._option():
                self._default_specification_()
            self._error('no available options')

    @graken()
    def _value_expression_(self):
        with self._choice():
            with self._option():
                self._numeric_value_expression_()
            with self._option():
                self._string_value_expression_()
            with self._option():
                self._datetime_value_expression_()
            with self._option():
                self._interval_value_expression_()
            self._error('no available options')

    @graken()
    def _numeric_value_expression_(self):
        with self._choice():
            with self._option():
                self._term_()
            with self._option():
                self._numeric_value_expression_()
                self._token('+')
                self._term_()
            with self._option():
                self._numeric_value_expression_()
                self._token('-')
                self._term_()
            self._error('no available options')

    @graken()
    def _term_(self):
        with self._choice():
            with self._option():
                self._factor_()
            with self._option():
                self._term_()
                self._token('*')
                self._factor_()
            with self._option():
                self._term_()
                self._token('/')
                self._factor_()
            self._error('no available options')

    @graken()
    def _factor_(self):
        with self._optional():
            self._sign_()
        self._numeric_primary_()

    @graken()
    def _numeric_primary_(self):
        with self._choice():
            with self._option():
                self._value_expression_primary_()
            with self._option():
                self._numeric_value_function_()
            self._error('no available options')

    @graken()
    def _value_expression_primary_(self):
        with self._choice():
            with self._option():
                self._unsigned_value_specification_()
            with self._option():
                self._column_reference_()
            with self._option():
                self._set_function_specification_()
            with self._option():
                self._scalar_subquery_()
            with self._option():
                self._case_expression_()
            with self._option():
                self._token('(')
                self._value_expression_()
                self._token(')')
            with self._option():
                self._cast_specification_()
            self._error('no available options')

    @graken()
    def _unsigned_value_specification_(self):
        with self._choice():
            with self._option():
                self._unsigned_literal_()
            with self._option():
                self._general_value_specification_()
            self._error('no available options')

    @graken()
    def _unsigned_literal_(self):
        with self._choice():
            with self._option():
                self._unsigned_numeric_literal_()
            with self._option():
                self._general_literal_()
            self._error('no available options')

    @graken()
    def _general_value_specification_(self):
        with self._choice():
            with self._option():
                self._parameter_specification_()
            with self._option():
                self._dynamic_parameter_specification_()
            with self._option():
                self._token('USER')
            with self._option():
                self._token('CURRENT_USER')
            with self._option():
                self._token('SESSION_USER')
            with self._option():
                self._token('SYSTEM_USER')
            with self._option():
                self._token('VALUE')
            self._error('expecting one of: CURRENT_USER SESSION_USER SYSTEM_USER USER VALUE')

    @graken()
    def _parameter_specification_(self):
        self._parameter_name_()
        with self._optional():
            self._indicator_parameter_()

    @graken()
    def _parameter_name_(self):
        self._token(':')
        self._IDENTIFIER_()

    @graken()
    def _indicator_parameter_(self):
        with self._optional():
            self._token('INDICATOR')
        self._parameter_name_()

    @graken()
    def _dynamic_parameter_specification_(self):
        self._token('?')

    @graken()
    def _column_reference_(self):
        with self._optional():
            self._qualifier_()
            self._token('.')
        self._column_name_()

    @graken()
    def _qualifier_(self):
        with self._choice():
            with self._option():
                self._table_name_()
            with self._option():
                self._correlation_name_()
            self._error('no available options')

    @graken()
    def _correlation_name_(self):
        self._IDENTIFIER_()

    @graken()
    def _set_function_specification_(self):
        with self._choice():
            with self._option():
                self._token('COUNT')
                self._token('(')
                self._token('*')
                self._token(')')
            with self._option():
                self._general_set_function_()
            self._error('expecting one of: COUNT')

    @graken()
    def _general_set_function_(self):
        self._set_function_type_()
        self._token('(')
        with self._optional():
            self._set_quantifier_()
        self._value_expression_()
        self._token(')')

    @graken()
    def _set_function_type_(self):
        with self._choice():
            with self._option():
                self._token('AVG')
            with self._option():
                self._token('MAX')
            with self._option():
                self._token('MIN')
            with self._option():
                self._token('SUM')
            with self._option():
                self._token('COUNT')
            self._error('expecting one of: AVG COUNT MAX MIN SUM')

    @graken()
    def _set_quantifier_(self):
        with self._choice():
            with self._option():
                self._token('DISTINCT')
            with self._option():
                self._token('ALL')
            self._error('expecting one of: ALL DISTINCT')

    @graken()
    def _scalar_subquery_(self):
        self._subquery_()

    @graken()
    def _subquery_(self):
        self._token('(')
        self._query_expression_()
        self._token(')')

    @graken()
    def _query_expression_(self):
        with self._choice():
            with self._option():
                self._non_join_query_expression_()
            with self._option():
                self._joined_table_()
            self._error('no available options')

    @graken()
    def _non_join_query_expression_(self):
        with self._choice():
            with self._option():
                self._non_join_query_term_()
            with self._option():
                self._query_expression_()
                self._token('UNION')
                with self._optional():
                    self._token('ALL')
                with self._optional():
                    self._corresponding_spec_()
                self._query_term_()
            with self._option():
                self._query_expression_()
                self._token('EXCEPT')
                with self._optional():
                    self._token('ALL')
                with self._optional():
                    self._corresponding_spec_()
                self._query_term_()
            self._error('no available options')

    @graken()
    def _non_join_query_term_(self):
        with self._choice():
            with self._option():
                self._non_join_query_primary_()
            with self._option():
                self._query_term_()
                self._token('INTERSECT')
                with self._optional():
                    self._token('ALL')
                with self._optional():
                    self._corresponding_spec_()
                self._query_primary_()
            self._error('no available options')

    @graken()
    def _non_join_query_primary_(self):
        with self._choice():
            with self._option():
                self._simple_table_()
            with self._option():
                self._token('(')
                self._non_join_query_expression_()
                self._token(')')
            self._error('no available options')

    @graken()
    def _simple_table_(self):
        with self._choice():
            with self._option():
                self._query_specification_()
            with self._option():
                self._table_value_constructor_()
            with self._option():
                self._explicit_table_()
            self._error('no available options')

    @graken()
    def _query_specification_(self):
        self._token('SELECT')
        with self._optional():
            self._set_quantifier_()
        self._select_list_()
        self._table_expression_()

    @graken()
    def _select_list_(self):
        with self._choice():
            with self._option():
                self._token('*')
            with self._option():
                self._select_sublist_()
                with self._optional():

                    def block0():
                        self._token(',')
                        self._select_sublist_()
                    self._positive_closure(block0)
            self._error('expecting one of: *')

    @graken()
    def _select_sublist_(self):
        with self._choice():
            with self._option():
                self._derived_column_()
            with self._option():
                self._qualifier_()
                self._token('.')
                self._token('*')
            self._error('no available options')

    @graken()
    def _derived_column_(self):
        self._value_expression_()
        with self._optional():
            self._as_clause_()

    @graken()
    def _as_clause_(self):
        with self._optional():
            self._token('AS')
        self._column_name_()

    @graken()
    def _table_expression_(self):
        self._from_clause_()
        with self._optional():
            self._where_clause_()
        with self._optional():
            self._group_by_clause_()
        with self._optional():
            self._having_clause_()

    @graken()
    def _from_clause_(self):
        self._token('FROM')
        self._table_reference_()
        with self._optional():

            def block0():
                self._token(',')
                self._table_reference_()
            self._positive_closure(block0)

    @graken()
    def _table_reference_(self):
        with self._choice():
            with self._option():
                self._table_name_()
                with self._optional():
                    self._correlation_specification_()
            with self._option():
                self._derived_table_()
                self._correlation_specification_()
            with self._option():
                self._joined_table_()
            self._error('no available options')

    @graken()
    def _correlation_specification_(self):
        with self._optional():
            self._token('AS')
        self._correlation_name_()
        with self._optional():
            self._token('(')
            self._derived_column_list_()
            self._token(')')

    @graken()
    def _derived_column_list_(self):
        self._column_name_list_()

    @graken()
    def _derived_table_(self):
        self._table_subquery_()

    @graken()
    def _table_subquery_(self):
        self._subquery_()

    @graken()
    def _joined_table_(self):
        with self._choice():
            with self._option():
                self._cross_join_()
            with self._option():
                self._qualified_join_()
            with self._option():
                self._token('(')
                self._joined_table_()
                self._token(')')
            self._error('no available options')

    @graken()
    def _cross_join_(self):
        self._table_reference_()
        self._token('CROSS')
        self._token('JOIN')
        self._table_reference_()

    @graken()
    def _qualified_join_(self):
        self._table_reference_()
        with self._optional():
            self._token('NATURAL')
        with self._optional():
            self._join_type_()
        self._token('JOIN')
        self._table_reference_()
        with self._optional():
            self._join_specification_()

    @graken()
    def _join_type_(self):
        with self._choice():
            with self._option():
                self._token('INNER')
            with self._option():
                self._outer_join_type_()
                with self._optional():
                    self._token('OUTER')
            with self._option():
                self._token('UNION')
            self._error('expecting one of: INNER UNION')

    @graken()
    def _outer_join_type_(self):
        with self._choice():
            with self._option():
                self._token('LEFT')
            with self._option():
                self._token('RIGHT')
            with self._option():
                self._token('FULL')
            self._error('expecting one of: FULL LEFT RIGHT')

    @graken()
    def _join_specification_(self):
        with self._choice():
            with self._option():
                self._join_condition_()
            with self._option():
                self._named_columns_join_()
            self._error('no available options')

    @graken()
    def _join_condition_(self):
        self._token('ON')
        self._search_condition_()

    @graken()
    def _named_columns_join_(self):
        self._token('USING')
        self._token('(')
        self._join_column_list_()
        self._token(')')

    @graken()
    def _join_column_list_(self):
        self._column_name_list_()

    @graken()
    def _where_clause_(self):
        self._token('WHERE')
        self._search_condition_()

    @graken()
    def _group_by_clause_(self):
        self._token('GROUP')
        self._token('BY')
        self._grouping_column_reference_list_()

    @graken()
    def _grouping_column_reference_list_(self):
        self._grouping_column_reference_()
        with self._optional():

            def block0():
                self._token(',')
                self._grouping_column_reference_()
            self._positive_closure(block0)

    @graken()
    def _grouping_column_reference_(self):
        self._column_reference_()
        with self._optional():
            self._collate_clause_()

    @graken()
    def _collate_clause_(self):
        self._token('COLLATE')
        self._collation_name_()

    @graken()
    def _collation_name_(self):
        self._qualified_name_()

    @graken()
    def _having_clause_(self):
        self._token('HAVING')
        self._search_condition_()

    @graken()
    def _table_value_constructor_(self):
        self._token('VALUES')
        self._table_value_constructor_list_()

    @graken()
    def _table_value_constructor_list_(self):
        self._row_value_constructor_()
        with self._optional():

            def block0():
                self._token(',')
                self._row_value_constructor_()
            self._positive_closure(block0)

    @graken()
    def _explicit_table_(self):
        self._token('TABLE')
        self._table_name_()

    @graken()
    def _query_term_(self):
        with self._choice():
            with self._option():
                self._non_join_query_term_()
            with self._option():
                self._joined_table_()
            self._error('no available options')

    @graken()
    def _corresponding_spec_(self):
        self._token('CORRESPONDING')
        with self._optional():
            self._token('BY')
            self._token('(')
            self._corresponding_column_list_()
            self._token(')')

    @graken()
    def _corresponding_column_list_(self):
        self._column_name_list_()

    @graken()
    def _query_primary_(self):
        with self._choice():
            with self._option():
                self._non_join_query_primary_()
            with self._option():
                self._joined_table_()
            self._error('no available options')

    @graken()
    def _case_expression_(self):
        with self._choice():
            with self._option():
                self._case_abbreviation_()
            with self._option():
                self._case_specification_()
            self._error('no available options')

    @graken()
    def _case_abbreviation_(self):
        with self._choice():
            with self._option():
                self._token('NULLIF')
                self._token('(')
                self._value_expression_()
                self._token(',')
                self._value_expression_()
                self._token(')')
            with self._option():
                self._token('COALESCE')
                self._token('(')
                self._value_expression_()

                def block0():
                    self._token(',')
                    self._value_expression_()
                self._closure(block0)
                self._token(')')
            self._error('no available options')

    @graken()
    def _case_specification_(self):
        with self._choice():
            with self._option():
                self._simple_case_()
            with self._option():
                self._searched_case_()
            self._error('no available options')

    @graken()
    def _simple_case_(self):
        self._token('CASE')
        self._case_operand_()

        def block0():
            self._simple_when_clause_()
        self._closure(block0)
        with self._optional():
            self._else_clause_()
        self._token('END')

    @graken()
    def _case_operand_(self):
        self._value_expression_()

    @graken()
    def _simple_when_clause_(self):
        self._token('WHEN')
        self._when_operand_()
        self._token('THEN')
        self._result_()

    @graken()
    def _when_operand_(self):
        self._value_expression_()

    @graken()
    def _result_(self):
        with self._choice():
            with self._option():
                self._result_expression_()
            with self._option():
                self._token('NULL')
            self._error('expecting one of: NULL')

    @graken()
    def _result_expression_(self):
        self._value_expression_()

    @graken()
    def _else_clause_(self):
        self._token('ELSE')
        self._result_()

    @graken()
    def _searched_case_(self):
        self._token('CASE')

        def block0():
            self._searched_when_clause_()
        self._closure(block0)
        with self._optional():
            self._else_clause_()
        self._token('END')

    @graken()
    def _searched_when_clause_(self):
        self._token('WHEN')
        self._search_condition_()
        self._token('THEN')
        self._result_()

    @graken()
    def _cast_specification_(self):
        self._token('CAST')
        self._token('(')
        self._cast_operand_()
        self._token('AS')
        self._cast_target_()
        self._token(')')

    @graken()
    def _cast_operand_(self):
        with self._choice():
            with self._option():
                self._value_expression_()
            with self._option():
                self._token('NULL')
            self._error('expecting one of: NULL')

    @graken()
    def _cast_target_(self):
        with self._choice():
            with self._option():
                self._domain_name_()
            with self._option():
                self._data_type_()
            self._error('no available options')

    @graken()
    def _numeric_value_function_(self):
        with self._choice():
            with self._option():
                self._position_expression_()
            with self._option():
                self._extract_expression_()
            with self._option():
                self._length_expression_()
            self._error('no available options')

    @graken()
    def _position_expression_(self):
        self._token('POSITION')
        self._token('(')
        self._character_value_expression_()
        self._token('IN')
        self._character_value_expression_()
        self._token(')')

    @graken()
    def _character_value_expression_(self):
        with self._choice():
            with self._option():
                self._concatenation_()
            with self._option():
                self._character_factor_()
            self._error('no available options')

    @graken()
    def _concatenation_(self):
        self._character_value_expression_()
        self._token('||')
        self._character_factor_()

    @graken()
    def _character_factor_(self):
        self._character_primary_()
        with self._optional():
            self._collate_clause_()

    @graken()
    def _character_primary_(self):
        with self._choice():
            with self._option():
                self._value_expression_primary_()
            with self._option():
                self._string_value_function_()
            self._error('no available options')

    @graken()
    def _string_value_function_(self):
        with self._choice():
            with self._option():
                self._character_value_function_()
            with self._option():
                self._bit_value_function_()
            self._error('no available options')

    @graken()
    def _character_value_function_(self):
        with self._choice():
            with self._option():
                self._character_substring_function_()
            with self._option():
                self._fold_()
            with self._option():
                self._form_of_use_conversion_()
            with self._option():
                self._character_translation_()
            with self._option():
                self._trim_function_()
            self._error('no available options')

    @graken()
    def _character_substring_function_(self):
        self._token('SUBSTRING')
        self._token('(')
        self._character_value_expression_()
        self._token('FROM')
        self._start_position_()
        with self._optional():
            self._token('FOR')
            self._string_length_()
        self._token(')')

    @graken()
    def _start_position_(self):
        self._numeric_value_expression_()

    @graken()
    def _string_length_(self):
        self._numeric_value_expression_()

    @graken()
    def _fold_(self):

        def block0():
            with self._choice():
                with self._option():
                    self._token('UPPER')
                with self._option():
                    self._token('LOWER')
                self._error('expecting one of: LOWER UPPER')
        self._closure(block0)
        self._token('(')
        self._character_value_expression_()
        self._token(')')

    @graken()
    def _form_of_use_conversion_(self):
        self._token('CONVERT')
        self._token('(')
        self._character_value_expression_()
        self._token('USING')
        self._form_of_use_conversion_name_()
        self._token(')')

    @graken()
    def _form_of_use_conversion_name_(self):
        self._qualified_name_()

    @graken()
    def _character_translation_(self):
        self._token('TRANSLATE')
        self._token('(')
        self._character_value_expression_()
        self._token('USING')
        self._translation_name_()
        self._token(')')

    @graken()
    def _translation_name_(self):
        self._qualified_name_()

    @graken()
    def _trim_function_(self):
        self._token('TRIM')
        self._token('(')
        self._trim_operands_()
        self._token(')')

    @graken()
    def _trim_operands_(self):
        with self._optional():
            with self._optional():
                self._trim_specification_()
            with self._optional():
                self._trim_character_()
            self._token('FROM')
        self._trim_source_()

    @graken()
    def _trim_specification_(self):
        with self._choice():
            with self._option():
                self._token('LEADING')
            with self._option():
                self._token('TRAILING')
            with self._option():
                self._token('BOTH')
            self._error('expecting one of: BOTH LEADING TRAILING')

    @graken()
    def _trim_character_(self):
        self._character_value_expression_()

    @graken()
    def _trim_source_(self):
        self._character_value_expression_()

    @graken()
    def _bit_value_function_(self):
        self._bit_substring_function_()

    @graken()
    def _bit_substring_function_(self):
        self._token('SUBSTRING')
        self._token('(')
        self._bit_value_expression_()
        self._token('FROM')
        self._start_position_()
        with self._optional():
            self._token('FOR')
            self._string_length_()
        self._token(')')

    @graken()
    def _bit_value_expression_(self):
        with self._choice():
            with self._option():
                self._bit_concatenation_()
            with self._option():
                self._bit_factor_()
            self._error('no available options')

    @graken()
    def _bit_concatenation_(self):
        self._bit_value_expression_()
        self._token('||')
        self._bit_factor_()

    @graken()
    def _bit_factor_(self):
        self._bit_primary_()

    @graken()
    def _bit_primary_(self):
        with self._choice():
            with self._option():
                self._value_expression_primary_()
            with self._option():
                self._string_value_function_()
            self._error('no available options')

    @graken()
    def _extract_expression_(self):
        self._token('EXTRACT')
        self._token('(')
        self._extract_field_()
        self._token('FROM')
        self._extract_source_()
        self._token(')')

    @graken()
    def _extract_field_(self):
        with self._choice():
            with self._option():
                self._datetime_field_()
            with self._option():
                self._time_zone_field_()
            self._error('no available options')

    @graken()
    def _datetime_field_(self):
        with self._choice():
            with self._option():
                self._non_second_datetime_field_()
            with self._option():
                self._token('SECOND')
            self._error('expecting one of: SECOND')

    @graken()
    def _time_zone_field_(self):
        with self._choice():
            with self._option():
                self._token('TIMEZONE_HOUR')
            with self._option():
                self._token('TIMEZONE_MINUTE')
            self._error('expecting one of: TIMEZONE_HOUR TIMEZONE_MINUTE')

    @graken()
    def _extract_source_(self):
        with self._choice():
            with self._option():
                self._datetime_value_expression_()
            with self._option():
                self._interval_value_expression_()
            self._error('no available options')

    @graken()
    def _datetime_value_expression_(self):
        with self._choice():
            with self._option():
                self._datetime_term_()
            with self._option():
                self._interval_value_expression_()
                self._token('+')
                self._datetime_term_()
            with self._option():
                self._datetime_value_expression_()
                self._token('+')
                self._interval_term_()
            with self._option():
                self._datetime_value_expression_()
                self._token('-')
                self._interval_term_()
            self._error('no available options')

    @graken()
    def _interval_term_(self):
        with self._choice():
            with self._option():
                self._interval_factor_()
            with self._option():
                self._interval_term_2_()
                self._token('*')
                self._factor_()
            with self._option():
                self._interval_term_2_()
                self._token('/')
                self._factor_()
            with self._option():
                self._term_()
                self._token('*')
                self._interval_factor_()
            self._error('no available options')

    @graken()
    def _interval_factor_(self):
        with self._optional():
            self._sign_()
        self._interval_primary_()

    @graken()
    def _interval_primary_(self):
        self._value_expression_primary_()
        with self._optional():
            self._interval_qualifier_()

    @graken()
    def _interval_term_2_(self):
        self._interval_term_()

    @graken()
    def _interval_value_expression_(self):
        with self._choice():
            with self._option():
                self._interval_term_()
            with self._option():
                self._interval_value_expression_1_()
                self._token('+')
                self._interval_term_1_()
            with self._option():
                self._interval_value_expression_1_()
                self._token('-')
                self._interval_term_1_()
            with self._option():
                self._token('(')
                self._datetime_value_expression_()
                self._token('-')
                self._datetime_term_()
                self._token(')')
                self._interval_qualifier_()
            self._error('no available options')

    @graken()
    def _interval_value_expression_1_(self):
        self._interval_value_expression_()

    @graken()
    def _interval_term_1_(self):
        self._interval_term_()

    @graken()
    def _datetime_term_(self):
        self._datetime_factor_()

    @graken()
    def _datetime_factor_(self):
        self._datetime_primary_()
        with self._optional():
            self._time_zone_()

    @graken()
    def _datetime_primary_(self):
        with self._choice():
            with self._option():
                self._value_expression_primary_()
            with self._option():
                self._datetime_value_function_()
            self._error('no available options')

    @graken()
    def _time_zone_(self):
        self._token('AT')
        self._time_zone_specifier_()

    @graken()
    def _time_zone_specifier_(self):
        with self._choice():
            with self._option():
                self._token('LOCAL')
            with self._option():
                self._token('TIME')
                self._token('ZONE')
                self._interval_value_expression_()
            self._error('expecting one of: LOCAL')

    @graken()
    def _length_expression_(self):
        with self._choice():
            with self._option():
                self._char_length_expression_()
            with self._option():
                self._octet_length_expression_()
            with self._option():
                self._bit_length_expression_()
            self._error('no available options')

    @graken()
    def _char_length_expression_(self):

        def block0():
            with self._choice():
                with self._option():
                    self._token('CHAR_LENGTH')
                with self._option():
                    self._token('CHARACTER_LENGTH')
                self._error('expecting one of: CHARACTER_LENGTH CHAR_LENGTH')
        self._closure(block0)
        self._token('(')
        self._string_value_expression_()
        self._token(')')

    @graken()
    def _string_value_expression_(self):
        with self._choice():
            with self._option():
                self._character_value_expression_()
            with self._option():
                self._bit_value_expression_()
            self._error('no available options')

    @graken()
    def _octet_length_expression_(self):
        self._token('OCTET_LENGTH')
        self._token('(')
        self._string_value_expression_()
        self._token(')')

    @graken()
    def _bit_length_expression_(self):
        self._token('BIT_LENGTH')
        self._token('(')
        self._string_value_expression_()
        self._token(')')

    @graken()
    def _null_specification_(self):
        self._token('NULL')

    @graken()
    def _default_specification_(self):
        self._token('DEFAULT')

    @graken()
    def _row_value_constructor_list_(self):
        self._row_value_constructor_element_()
        with self._optional():

            def block0():
                self._token(',')
                self._row_value_constructor_element_()
            self._positive_closure(block0)

    @graken()
    def _row_subquery_(self):
        self._subquery_()

    @graken()
    def _comp_op_(self):
        with self._choice():
            with self._option():
                self._token('=')
            with self._option():
                self._token('<>')
            with self._option():
                self._token('<')
            with self._option():
                self._token('>')
            with self._option():
                self._token('<=')
            with self._option():
                self._token('>=')
            self._error('expecting one of: < <= <> = > >=')

    @graken()
    def _between_predicate_(self):
        self._row_value_constructor_()
        with self._optional():
            self._token('NOT')
        self._token('BETWEEN')
        self._row_value_constructor_()
        self._token('AND')
        self._row_value_constructor_()

    @graken()
    def _in_predicate_(self):
        self._row_value_constructor_()
        with self._optional():
            self._token('NOT')
        self._token('IN')
        self._in_predicate_value_()

    @graken()
    def _in_predicate_value_(self):
        with self._choice():
            with self._option():
                self._table_subquery_()
            with self._option():
                self._token('(')
                self._in_value_list_()
                self._token(')')
            self._error('no available options')

    @graken()
    def _in_value_list_(self):
        self._value_expression_()

        def block0():
            self._token(',')
            self._value_expression_()
        self._closure(block0)

    @graken()
    def _like_predicate_(self):
        self._match_value_()
        with self._optional():
            self._token('NOT')
        self._token('LIKE')
        self._pattern_()
        with self._optional():
            self._token('ESCAPE')
            self._escape_character_()

    @graken()
    def _match_value_(self):
        self._character_value_expression_()

    @graken()
    def _pattern_(self):
        self._character_value_expression_()

    @graken()
    def _escape_character_(self):
        self._character_value_expression_()

    @graken()
    def _null_predicate_(self):
        self._token('IS')
        with self._optional():
            self._token('NOT')
        self._token('NULL')

    @graken()
    def _quantified_comparison_predicate_(self):
        self._row_value_constructor_()
        self._comp_op_()
        self._quantifier_()
        self._table_subquery_()

    @graken()
    def _quantifier_(self):
        with self._choice():
            with self._option():
                self._all_()
            with self._option():
                self._some_()
            self._error('no available options')

    @graken()
    def _all_(self):
        self._token('ALL')

    @graken()
    def _some_(self):
        with self._choice():
            with self._option():
                self._token('SOME')
            with self._option():
                self._token('ANY')
            self._error('expecting one of: ANY SOME')

    @graken()
    def _exists_predicate_(self):
        self._token('EXISTS')
        self._table_subquery_()

    @graken()
    def _match_predicate_(self):
        self._row_value_constructor_()
        self._token('MATCH')
        with self._optional():
            self._token('UNIQUE')
        with self._optional():
            with self._choice():
                with self._option():
                    self._token('PARTIAL')
                with self._option():
                    self._token('FULL')
                self._error('expecting one of: FULL PARTIAL')
        self._table_subquery_()

    @graken()
    def _overlaps_predicate_(self):
        self._row_value_constructor_1_()
        self._token('OVERLAPS')
        self._row_value_constructor_2_()

    @graken()
    def _row_value_constructor_1_(self):
        self._row_value_constructor_()

    @graken()
    def _row_value_constructor_2_(self):
        self._row_value_constructor_()

    @graken()
    def _truth_value_(self):
        with self._choice():
            with self._option():
                self._token('TRUE')
            with self._option():
                self._token('FALSE')
            with self._option():
                self._token('UNKNOWN')
            self._error('expecting one of: FALSE TRUE UNKNOWN')

    @graken()
    def _constraint_attributes_(self):
        with self._choice():
            with self._option():
                self._constraint_check_time_()
                with self._optional():
                    with self._optional():
                        self._token('NOT')
                    self._token('DEFERRABLE')
            with self._option():
                with self._optional():
                    self._token('NOT')
                self._token('DEFERRABLE')
                with self._optional():
                    self._constraint_check_time_()
            self._error('expecting one of: DEFERRABLE NOT')

    @graken()
    def _constraint_check_time_(self):
        with self._choice():
            with self._option():
                self._token('INITIALLY')
                self._token('DEFERRED')
            with self._option():
                self._token('INITIALLY')
                self._token('IMMEDIATE')
            self._error('expecting one of: INITIALLY')

    @graken()
    def _table_constraint_definition_(self):
        with self._optional():
            self._constraint_name_definition_()
        self._table_constraint_()
        with self._optional():
            self._constraint_check_time_()

    @graken()
    def _table_constraint_(self):
        with self._choice():
            with self._option():
                self._unique_constraint_definition_()
            with self._option():
                self._referential_constraint_definition_()
            with self._option():
                self._check_constraint_definition_()
            self._error('no available options')

    @graken()
    def _unique_constraint_definition_(self):
        self._unique_specification_()
        self._token('(')
        self._unique_column_list_()
        self._token(')')

    @graken()
    def _unique_column_list_(self):
        self._column_name_list_()

    @graken()
    def _referential_constraint_definition_(self):
        self._token('FOREIGN')
        self._token('KEY')
        self._token('(')
        self._referencing_columns_()
        self._token(')')
        self._references_specification_()

    @graken()
    def _referencing_columns_(self):
        self._reference_column_list_()

    @graken()
    def _order_by_clause_(self):
        self._token('ORDER')
        self._token('BY')
        self._sort_specification_list_()

    @graken()
    def _sort_specification_list_(self):
        self._sort_specification_()
        with self._optional():

            def block0():
                self._token(',')
                self._sort_specification_()
            self._positive_closure(block0)

    @graken()
    def _sort_specification_(self):
        self._sort_key_()
        with self._optional():
            self._collate_clause_()
        with self._optional():
            self._ordering_specification_()

    @graken()
    def _sort_key_(self):
        with self._choice():
            with self._option():
                self._column_name_()
            with self._option():
                self._unsigned_integer_()
            self._error('no available options')

    @graken()
    def _ordering_specification_(self):
        with self._choice():
            with self._option():
                self._token('ASC')
            with self._option():
                self._token('DESC')
            self._error('expecting one of: ASC DESC')

    @graken()
    def _sql_schema_statement_(self):
        with self._choice():
            with self._option():
                self._sql_schema_definition_statement_()
            with self._option():
                self._sql_schema_manipulation_statement_()
            self._error('no available options')

    @graken()
    def _sql_schema_definition_statement_(self):
        with self._choice():
            with self._option():
                self._schema_definition_()
            with self._option():
                self._table_definition_()
            with self._option():
                self._view_definition_()
            with self._option():
                self._grant_statement_()
            with self._option():
                self._domain_definition_()
            with self._option():
                self._character_set_definition_()
            with self._option():
                self._collation_definition_()
            with self._option():
                self._translation_definition_()
            with self._option():
                self._assertion_definition_()
            self._error('no available options')

    @graken()
    def _schema_definition_(self):
        self._token('CREATE')
        self._token('SCHEMA')
        self._schema_name_clause_()
        with self._optional():
            self._schema_character_set_specification_()
        with self._optional():

            def block0():
                self._schema_element_()
            self._positive_closure(block0)

    @graken()
    def _schema_name_clause_(self):
        with self._choice():
            with self._option():
                self._schema_name_()
            with self._option():
                self._token('AUTHORIZATION')
                self._schema_authorization_IDENTIFIER_()
            with self._option():
                self._schema_name_()
                self._token('AUTHORIZATION')
                self._schema_authorization_IDENTIFIER_()
            self._error('no available options')

    @graken()
    def _schema_authorization_IDENTIFIER_(self):
        self._authorization_IDENTIFIER_()

    @graken()
    def _schema_character_set_specification_(self):
        self._token('DEFAULT')
        self._token('CHARACTER')
        self._token('SET')
        self._character_set_name_()

    @graken()
    def _schema_element_(self):
        with self._choice():
            with self._option():
                self._domain_definition_()
            with self._option():
                self._table_definition_()
            with self._option():
                self._view_definition_()
            with self._option():
                self._grant_statement_()
            with self._option():
                self._assertion_definition_()
            with self._option():
                self._character_set_definition_()
            with self._option():
                self._collation_definition_()
            with self._option():
                self._translation_definition_()
            self._error('no available options')

    @graken()
    def _domain_definition_(self):
        self._token('CREATE')
        self._token('DOMAIN')
        self._domain_name_()
        with self._optional():
            self._token('AS')
        self._data_type_()
        with self._optional():
            self._default_clause_()
        with self._optional():
            self._domain_constraint_()
        with self._optional():
            self._collate_clause_()

    @graken()
    def _domain_constraint_(self):
        with self._optional():
            self._constraint_name_definition_()
        self._check_constraint_definition_()
        with self._optional():
            self._constraint_attributes_()

    @graken()
    def _table_definition_(self):
        self._token('CREATE')
        with self._optional():

            def block0():
                with self._choice():
                    with self._option():
                        self._token('GLOBAL')
                    with self._option():
                        self._token('LOCAL')
                    self._error('expecting one of: GLOBAL LOCAL')
            self._closure(block0)
            self._token('TEMPORARY')
        self._token('TABLE')
        self._table_name_()
        self._table_element_list_()
        with self._optional():
            self._token('ON')
            self._token('COMMIT')

            def block2():
                with self._choice():
                    with self._option():
                        self._token('DELETE')
                    with self._option():
                        self._token('PRESERVE')
                    self._error('expecting one of: DELETE PRESERVE')
            self._closure(block2)
            self._token('ROWS')

    @graken()
    def _view_definition_(self):
        self._token('CREATE')
        self._token('VIEW')
        self._table_name_()
        with self._optional():
            self._token('(')
            self._view_column_list_()
            self._token(')')
        self._token('AS')
        self._query_expression_()
        with self._optional():
            self._token('WITH')
            with self._optional():
                self._levels_clause_()
            self._token('CHECK')
            self._token('OPTION')

    @graken()
    def _view_column_list_(self):
        self._column_name_list_()

    @graken()
    def _levels_clause_(self):
        with self._choice():
            with self._option():
                self._token('CASCADED')
            with self._option():
                self._token('LOCAL')
            self._error('expecting one of: CASCADED LOCAL')

    @graken()
    def _grant_statement_(self):
        self._token('GRANT')
        self._privileges_()
        self._token('ON')
        self._object_name_()
        self._token('TO')
        self._grantee_()
        with self._optional():

            def block0():
                self._token(',')
                self._grantee_()
            self._positive_closure(block0)
        with self._optional():
            self._token('WITH')
            self._token('GRANT')
            self._token('OPTION')

    @graken()
    def _privileges_(self):
        with self._choice():
            with self._option():
                self._token('ALL')
                self._token('PRIVILEGES')
            with self._option():
                self._action_list_()
            self._error('expecting one of: ALL')

    @graken()
    def _action_list_(self):
        self._action_()
        with self._optional():

            def block0():
                self._token(',')
                self._action_()
            self._positive_closure(block0)

    @graken()
    def _action_(self):
        with self._choice():
            with self._option():
                self._token('SELECT')
            with self._option():
                self._token('DELETE')
            with self._option():
                self._token('INSERT')
                with self._optional():
                    self._token('(')
                    self._privilege_column_list_()
                    self._token(')')
            with self._option():
                self._token('UPDATE')
                with self._optional():
                    self._token('(')
                    self._privilege_column_list_()
                    self._token(')')
            with self._option():
                self._token('REFERENCES')
                with self._optional():
                    self._token('(')
                    self._privilege_column_list_()
                    self._token(')')
            with self._option():
                self._token('USAGE')
            self._error('expecting one of: DELETE INSERT REFERENCES SELECT UPDATE USAGE')

    @graken()
    def _privilege_column_list_(self):
        self._column_name_list_()

    @graken()
    def _object_name_(self):
        with self._choice():
            with self._option():
                with self._optional():
                    self._token('TABLE')
                self._table_name_()
            with self._option():
                self._token('DOMAIN')
                self._domain_name_()
            with self._option():
                self._token('COLLATION')
                self._collation_name_()
            with self._option():
                self._token('CHARACTER')
                self._token('SET')
                self._character_set_name_()
            with self._option():
                self._token('TRANSLATION')
                self._translation_name_()
            self._error('no available options')

    @graken()
    def _grantee_(self):
        with self._choice():
            with self._option():
                self._token('PUBLIC')
            with self._option():
                self._authorization_IDENTIFIER_()
            self._error('expecting one of: PUBLIC')

    @graken()
    def _assertion_definition_(self):
        self._token('CREATE')
        self._token('ASSERTION')
        self._constraint_name_()
        self._assertion_check_()
        with self._optional():
            self._constraint_attributes_()

    @graken()
    def _assertion_check_(self):
        self._token('CHECK')
        self._token('(')
        self._search_condition_()
        self._token(')')

    @graken()
    def _character_set_definition_(self):
        self._token('CREATE')
        self._token('CHARACTER')
        self._token('SET')
        self._character_set_name_()
        with self._optional():
            self._token('AS')
        self._character_set_source_()
        with self._optional():
            with self._choice():
                with self._option():
                    self._collate_clause_()
                with self._option():
                    self._limited_collation_definition_()
                self._error('no available options')

    @graken()
    def _character_set_source_(self):
        self._token('GET')
        self._character_set_name_()

    @graken()
    def _limited_collation_definition_(self):
        self._token('COLLATION')
        self._token('FROM')
        self._collation_source_()

    @graken()
    def _collation_source_(self):
        with self._choice():
            with self._option():
                self._collating_sequence_definition_()
            with self._option():
                self._translation_collation_()
            self._error('no available options')

    @graken()
    def _collating_sequence_definition_(self):
        with self._choice():
            with self._option():
                self._external_collation_()
            with self._option():
                self._schema_collation_name_()
            with self._option():
                self._token('DESC')
                self._token('(')
                self._collation_name_()
                self._token(')')
            with self._option():
                self._token('DEFAULT')
            self._error('expecting one of: DEFAULT')

    @graken()
    def _external_collation_(self):
        self._token('EXTERNAL')
        self._token('(')
        self._token("'")
        self._external_collation_name_()
        self._token("'")
        self._token(')')

    @graken()
    def _external_collation_name_(self):
        with self._choice():
            with self._option():
                self._standard_collation_name_()
            with self._option():
                self._implementation_defined_collation_name_()
            self._error('no available options')

    @graken()
    def _standard_collation_name_(self):
        self._collation_name_()

    @graken()
    def _implementation_defined_collation_name_(self):
        self._collation_name_()

    @graken()
    def _schema_collation_name_(self):
        self._collation_name_()

    @graken()
    def _translation_collation_(self):
        self._token('TRANSLATION')
        self._translation_name_()
        with self._optional():
            self._token('THEN')
            self._token('COLLATION')
            self._collation_name_()

    @graken()
    def _collation_definition_(self):
        self._token('CREATE')
        self._token('COLLATION')
        self._collation_name_()
        self._token('FOR')
        self._character_set_name_()
        self._token('FROM')
        self._collation_source_()
        with self._optional():
            self._pad_attribute_()

    @graken()
    def _pad_attribute_(self):
        with self._choice():
            with self._option():
                self._token('NO')
                self._token('PAD')
            with self._option():
                self._token('PAD')
                self._token('SPACE')
            self._error('expecting one of: NO PAD')

    @graken()
    def _translation_definition_(self):
        self._token('CREATE')
        self._token('TRANSLATION')
        self._translation_name_()
        self._token('FOR')
        self._character_set_name_()
        self._token('TO')
        self._character_set_name_()
        self._token('FROM')
        self._translation_source_()

    @graken()
    def _translation_source_(self):
        self._translation_specification_()

    @graken()
    def _translation_specification_(self):
        with self._choice():
            with self._option():
                self._external_translation_()
            with self._option():
                self._token('IDENTITY')
            with self._option():
                self._schema_translation_name_()
            self._error('expecting one of: IDENTITY')

    @graken()
    def _external_translation_(self):
        self._token('EXTERNAL')
        self._token('(')
        self._token("'")
        self._external_translation_name_()
        self._token("'")
        self._token(')')

    @graken()
    def _external_translation_name_(self):
        with self._choice():
            with self._option():
                self._standard_translation_name_()
            with self._option():
                self._implementation_defined_translation_name_()
            self._error('no available options')

    @graken()
    def _standard_translation_name_(self):
        self._translation_name_()

    @graken()
    def _implementation_defined_translation_name_(self):
        self._translation_name_()

    @graken()
    def _schema_translation_name_(self):
        self._translation_name_()

    @graken()
    def _sql_schema_manipulation_statement_(self):
        with self._choice():
            with self._option():
                self._drop_schema_statement_()
            with self._option():
                self._alter_table_statement_()
            with self._option():
                self._drop_table_statement_()
            with self._option():
                self._drop_view_statement_()
            with self._option():
                self._revoke_statement_()
            with self._option():
                self._alter_domain_statement_()
            with self._option():
                self._drop_domain_statement_()
            with self._option():
                self._drop_character_set_statement_()
            with self._option():
                self._drop_collation_statement_()
            with self._option():
                self._drop_translation_statement_()
            with self._option():
                self._drop_assertion_statement_()
            self._error('no available options')

    @graken()
    def _drop_schema_statement_(self):
        self._token('DROP')
        self._token('SCHEMA')
        self._schema_name_()
        self._drop_behaviour_()

    @graken()
    def _drop_behaviour_(self):
        with self._choice():
            with self._option():
                self._token('CASCADE')
            with self._option():
                self._token('RESTRICT')
            self._error('expecting one of: CASCADE RESTRICT')

    @graken()
    def _alter_table_statement_(self):
        self._token('ALTER')
        self._token('TABLE')
        self._table_name_()
        self._alter_table_action_()

    @graken()
    def _alter_table_action_(self):
        with self._choice():
            with self._option():
                self._add_column_definition_()
            with self._option():
                self._alter_column_definition_()
            with self._option():
                self._drop_column_definition_()
            with self._option():
                self._add_table_constraint_definition_()
            with self._option():
                self._drop_table_constraint_definition_()
            self._error('no available options')

    @graken()
    def _add_column_definition_(self):
        self._token('ADD')
        with self._optional():
            self._token('COLUMN')
        self._column_definition_()

    @graken()
    def _alter_column_definition_(self):
        self._token('ALTER')
        with self._optional():
            self._token('COLUMN')
        self._column_name_()
        self._alter_column_action_()

    @graken()
    def _alter_column_action_(self):
        with self._choice():
            with self._option():
                self._set_column_default_clause_()
            with self._option():
                self._drop_column_default_clause_()
            self._error('no available options')

    @graken()
    def _set_column_default_clause_(self):
        self._token('SET')
        self._default_clause_()

    @graken()
    def _drop_column_default_clause_(self):
        self._token('DROP')
        self._token('DEFAULT')

    @graken()
    def _drop_column_definition_(self):
        self._token('DROP')
        with self._optional():
            self._token('COLUMN')
        self._column_name_()
        self._drop_behaviour_()

    @graken()
    def _add_table_constraint_definition_(self):
        self._token('ADD')
        self._table_constraint_definition_()

    @graken()
    def _drop_table_constraint_definition_(self):
        self._token('DROP')
        self._token('CONSTRAINT')
        self._constraint_name_()
        self._drop_behaviour_()

    @graken()
    def _drop_table_statement_(self):
        self._token('DROP')
        self._token('TABLE')
        self._table_name_()
        self._drop_behaviour_()

    @graken()
    def _drop_view_statement_(self):
        self._token('DROP')
        self._token('VIEW')
        self._table_name_()
        self._drop_behaviour_()

    @graken()
    def _revoke_statement_(self):
        self._token('REVOKE')
        with self._optional():
            self._token('GRANT')
            self._token('OPTION')
            self._token('FOR')
        self._privileges_()
        self._token('ON')
        self._object_name_()
        self._token('FROM')
        self._grantee_()
        with self._optional():

            def block0():
                self._token(',')
                self._grantee_()
            self._positive_closure(block0)
        self._drop_behaviour_()

    @graken()
    def _alter_domain_statement_(self):
        self._token('ALTER')
        self._token('DOMAIN')
        self._domain_name_()
        self._alter_domain_action_()

    @graken()
    def _alter_domain_action_(self):
        with self._choice():
            with self._option():
                self._set_domain_default_clause_()
            with self._option():
                self._drop_domain_default_clause_()
            with self._option():
                self._add_domain_constraint_definition_()
            with self._option():
                self._drop_domain_constraint_definition_()
            self._error('no available options')

    @graken()
    def _set_domain_default_clause_(self):
        self._token('SET')
        self._default_clause_()

    @graken()
    def _drop_domain_default_clause_(self):
        self._token('DROP')
        self._token('DEFAULT')

    @graken()
    def _add_domain_constraint_definition_(self):
        self._token('ADD')
        self._domain_constraint_()

    @graken()
    def _drop_domain_constraint_definition_(self):
        self._token('DROP')
        self._token('CONSTRAINT')
        self._constraint_name_()

    @graken()
    def _drop_domain_statement_(self):
        self._token('DROP')
        self._token('DOMAIN')
        self._domain_name_()
        self._drop_behaviour_()

    @graken()
    def _drop_character_set_statement_(self):
        self._token('DROP')
        self._token('CHARACTER')
        self._token('SET')
        self._character_set_name_()

    @graken()
    def _drop_collation_statement_(self):
        self._token('DROP')
        self._token('COLLATION')
        self._collation_name_()

    @graken()
    def _drop_translation_statement_(self):
        self._token('DROP')
        self._token('TRANSLATION')
        self._translation_name_()

    @graken()
    def _drop_assertion_statement_(self):
        self._token('DROP')
        self._token('ASSERTION')
        self._constraint_name_()

    @graken()
    def _simple_value_specification_(self):
        with self._choice():
            with self._option():
                self._parameter_name_()
            with self._option():
                self._literal_()
            self._error('no available options')

    @graken()
    def _delete_statement_searched_(self):
        self._token('DELETE')
        self._token('FROM')
        self._table_name_()
        with self._optional():
            self._token('WHERE')
            self._search_condition_()

    @graken()
    def _insert_statement_(self):
        self._token('INSERT')
        self._token('INTO')
        self._table_name_()
        self._insert_columns_and_source_()

    @graken()
    def _insert_columns_and_source_(self):
        with self._choice():
            with self._option():
                with self._optional():
                    self._token('(')
                    self._insert_column_list_()
                    self._token(')')
                self._query_expression_()
            with self._option():
                self._token('DEFAULT')
                self._token('VALUES')
            self._error('expecting one of: DEFAULT')

    @graken()
    def _insert_column_list_(self):
        self._column_name_list_()

    @graken()
    def _set_clause_list_(self):
        self._set_clause_()
        with self._optional():

            def block0():
                self._token(',')
                self._set_clause_()
            self._positive_closure(block0)

    @graken()
    def _set_clause_(self):
        self._object_column_()
        self._token('=')
        self._update_source_()

    @graken()
    def _object_column_(self):
        self._column_name_()

    @graken()
    def _update_source_(self):
        with self._choice():
            with self._option():
                self._value_expression_()
            with self._option():
                self._null_specification_()
            with self._option():
                self._token('DEFAULT')
            self._error('expecting one of: DEFAULT')

    @graken()
    def _update_statement_searched_(self):
        self._token('UPDATE')
        self._table_name_()
        self._token('SET')
        self._set_clause_list_()
        with self._optional():
            self._token('WHERE')
            self._search_condition_()

    @graken()
    def _sql_transaction_statement_(self):
        with self._choice():
            with self._option():
                self._set_transaction_statement_()
            with self._option():
                self._set_constraints_mode_statement_()
            with self._option():
                self._commit_statement_()
            with self._option():
                self._rollback_statement_()
            self._error('no available options')

    @graken()
    def _set_transaction_statement_(self):
        self._token('SET')
        self._token('TRANSACTION')
        self._transaction_mode_()
        with self._optional():

            def block0():
                self._token(',')
                self._transaction_mode_()
            self._positive_closure(block0)

    @graken()
    def _transaction_mode_(self):
        with self._choice():
            with self._option():
                self._isolation_level_()
            with self._option():
                self._transaction_access_mode_()
            with self._option():
                self._diagnostics_size_()
            self._error('no available options')

    @graken()
    def _isolation_level_(self):
        self._token('ISOLATION')
        self._token('LEVEL')
        self._level_of_isolation_()

    @graken()
    def _level_of_isolation_(self):
        with self._choice():
            with self._option():
                self._token('READ')
                self._token('UNCOMMITTED')
            with self._option():
                self._token('READ')
                self._token('COMMITTED')
            with self._option():
                self._token('REPEATABLE')
                self._token('READ')
            with self._option():
                self._token('SERIALIZABLE')
            self._error('expecting one of: READ REPEATABLE SERIALIZABLE')

    @graken()
    def _transaction_access_mode_(self):
        with self._choice():
            with self._option():
                self._token('READ')
                self._token('ONLY')
            with self._option():
                self._token('READ')
                self._token('WRITE')
            self._error('expecting one of: READ')

    @graken()
    def _diagnostics_size_(self):
        self._token('DIAGNOSTICS')
        self._token('SIZE')
        self._number_of_conditions_()

    @graken()
    def _number_of_conditions_(self):
        self._simple_value_specification_()

    @graken()
    def _set_constraints_mode_statement_(self):
        self._token('SET')
        self._token('CONSTRAINTS')
        self._constraint_name_list_()

        def block0():
            with self._choice():
                with self._option():
                    self._token('DEFERRED')
                with self._option():
                    self._token('IMMEDIATE')
                self._error('expecting one of: DEFERRED IMMEDIATE')
        self._closure(block0)

    @graken()
    def _constraint_name_list_(self):
        with self._choice():
            with self._option():
                self._token('ALL')
            with self._option():
                self._constraint_name_()
                with self._optional():

                    def block0():
                        self._token(',')
                        self._constraint_name_()
                    self._positive_closure(block0)
            self._error('expecting one of: ALL')

    @graken()
    def _commit_statement_(self):
        self._token('COMMIT')
        with self._optional():
            self._token('WORK')

    @graken()
    def _rollback_statement_(self):
        self._token('ROLLBACK')
        with self._optional():
            self._token('WORK')

    @graken()
    def _sql_connection_statement_(self):
        with self._choice():
            with self._option():
                self._connect_statement_()
            with self._option():
                self._set_connection_statement_()
            with self._option():
                self._disconnect_statement_()
            self._error('no available options')

    @graken()
    def _connect_statement_(self):
        self._token('CONNECT')
        self._token('TO')
        self._connection_target_()

    @graken()
    def _connection_target_(self):
        with self._choice():
            with self._option():
                self._sql_server_name_()
                with self._optional():
                    self._token('AS')
                    self._connection_name_()
                with self._optional():
                    self._token('USER')
                    self._user_name_()
            with self._option():
                self._token('DEFAULT')
            self._error('expecting one of: DEFAULT')

    @graken()
    def _sql_server_name_(self):
        self._simple_value_specification_()

    @graken()
    def _connection_name_(self):
        self._simple_value_specification_()

    @graken()
    def _user_name_(self):
        self._simple_value_specification_()

    @graken()
    def _set_connection_statement_(self):
        self._token('SET')
        self._token('CONNECTION')
        self._connection_object_()

    @graken()
    def _connection_object_(self):
        with self._choice():
            with self._option():
                self._token('DEFAULT')
            with self._option():
                self._connection_name_()
            self._error('expecting one of: DEFAULT')

    @graken()
    def _disconnect_statement_(self):
        self._token('DISCONNECT')
        self._disconnect_object_()

    @graken()
    def _disconnect_object_(self):
        with self._choice():
            with self._option():
                self._connection_object_()
            with self._option():
                self._token('ALL')
            with self._option():
                self._token('CURRENT')
            self._error('expecting one of: ALL CURRENT')

    @graken()
    def _sql_session_statement_(self):
        with self._choice():
            with self._option():
                self._set_catalog_statement_()
            with self._option():
                self._set_schema_statement_()
            with self._option():
                self._set_names_statement_()
            with self._option():
                self._set_session_authorization_IDENTIFIER_statement_()
            with self._option():
                self._set_local_time_zone_statement_()
            self._error('no available options')

    @graken()
    def _set_catalog_statement_(self):
        self._token('SET')
        self._token('CATALOG')
        self._value_specification_()

    @graken()
    def _value_specification_(self):
        with self._choice():
            with self._option():
                self._literal_()
            with self._option():
                self._general_value_specification_()
            self._error('no available options')

    @graken()
    def _set_schema_statement_(self):
        self._token('SET')
        self._token('SCHEMA')
        self._value_specification_()

    @graken()
    def _set_names_statement_(self):
        self._token('SET')
        self._token('NAMES')
        self._value_specification_()

    @graken()
    def _set_session_authorization_IDENTIFIER_statement_(self):
        self._token('SET')
        self._token('SESSION')
        self._token('AUTHORIZATION')
        self._value_specification_()

    @graken()
    def _set_local_time_zone_statement_(self):
        self._token('SET')
        self._token('TIME')
        self._token('ZONE')
        self._set_time_zone_value_()

    @graken()
    def _set_time_zone_value_(self):
        with self._choice():
            with self._option():
                self._interval_value_expression_()
            with self._option():
                self._token('LOCAL')
            self._error('expecting one of: LOCAL')

    @graken()
    def _direct_sql_statement_(self):
        with self._choice():
            with self._option():
                self._direct_sql_data_statement_()
            with self._option():
                self._sql_schema_statement_()
            with self._option():
                self._sql_transaction_statement_()
            with self._option():
                self._sql_connection_statement_()
            with self._option():
                self._sql_session_statement_()
            self._error('no available options')

    @graken()
    def _direct_sql_data_statement_(self):
        with self._choice():
            with self._option():
                self._delete_statement_searched_()
            with self._option():
                self._direct_select_statement_multiple_rows_()
            with self._option():
                self._insert_statement_()
            with self._option():
                self._update_statement_searched_()
            with self._option():
                self._temporary_table_declaration_()
            self._error('no available options')

    @graken()
    def _direct_select_statement_multiple_rows_(self):
        self._query_expression_()
        with self._optional():
            self._order_by_clause_()


class SqlSemantics(object):
    def start(self, ast):
        return ast

    def CHARACTER(self, ast):
        return ast

    def LETTER(self, ast):
        return ast

    def DIGIT(self, ast):
        return ast

    def SPECIAL_CHARACTER(self, ast):
        return ast

    def SPACE(self, ast):
        return ast

    def REGULAR_IDENTIFIER(self, ast):
        return ast

    def IDENTIFIER_BODY(self, ast):
        return ast

    def IDENTIFIER_START(self, ast):
        return ast

    def IDENTIFIER_PART(self, ast):
        return ast

    def unsigned_numeric_literal(self, ast):
        return ast

    def exact_numeric_literal(self, ast):
        return ast

    def unsigned_integer(self, ast):
        return ast

    def approximate_numeric_literal(self, ast):
        return ast

    def mantissa(self, ast):
        return ast

    def exponent(self, ast):
        return ast

    def signed_integer(self, ast):
        return ast

    def sign(self, ast):
        return ast

    def national_character_string_literal(self, ast):
        return ast

    def character_representation(self, ast):
        return ast

    def nonquote_character(self, ast):
        return ast

    def quote_symbol(self, ast):
        return ast

    def separator(self, ast):
        return ast

    def comment(self, ast):
        return ast

    def comment_introducer(self, ast):
        return ast

    def comment_character(self, ast):
        return ast

    def NEWLINE(self, ast):
        return ast

    def bit_string_literal(self, ast):
        return ast

    def bit(self, ast):
        return ast

    def hex_string_literal(self, ast):
        return ast

    def hexit(self, ast):
        return ast

    def character_string_literal(self, ast):
        return ast

    def introducer(self, ast):
        return ast

    def character_set_name(self, ast):
        return ast

    def schema_name(self, ast):
        return ast

    def catalog_name(self, ast):
        return ast

    def IDENTIFIER(self, ast):
        return ast

    def actual_IDENTIFIER(self, ast):
        return ast

    def delimited_IDENTIFIER(self, ast):
        return ast

    def delimited_IDENTIFIER_BODY(self, ast):
        return ast

    def delimited_IDENTIFIER_PART(self, ast):
        return ast

    def doublequote_symbol(self, ast):
        return ast

    def unqualified_schema_name(self, ast):
        return ast

    def date_string(self, ast):
        return ast

    def date_value(self, ast):
        return ast

    def years_value(self, ast):
        return ast

    def datetime_value(self, ast):
        return ast

    def months_value(self, ast):
        return ast

    def days_value(self, ast):
        return ast

    def time_string(self, ast):
        return ast

    def time_value(self, ast):
        return ast

    def hours_value(self, ast):
        return ast

    def minutes_value(self, ast):
        return ast

    def seconds_value(self, ast):
        return ast

    def seconds_integer_value(self, ast):
        return ast

    def seconds_fraction(self, ast):
        return ast

    def time_zone_interval(self, ast):
        return ast

    def timestamp_string(self, ast):
        return ast

    def interval_string(self, ast):
        return ast

    def year_month_literal(self, ast):
        return ast

    def day_time_literal(self, ast):
        return ast

    def day_time_interval(self, ast):
        return ast

    def time_interval(self, ast):
        return ast

    def authorization_IDENTIFIER(self, ast):
        return ast

    def temporary_table_declaration(self, ast):
        return ast

    def qualified_local_table_name(self, ast):
        return ast

    def local_table_name(self, ast):
        return ast

    def qualified_IDENTIFIER(self, ast):
        return ast

    def table_element_list(self, ast):
        return ast

    def table_element(self, ast):
        return ast

    def column_definition(self, ast):
        return ast

    def column_name(self, ast):
        return ast

    def data_type(self, ast):
        return ast

    def character_string_type(self, ast):
        return ast

    def length(self, ast):
        return ast

    def national_character_string_type(self, ast):
        return ast

    def bit_string_type(self, ast):
        return ast

    def numeric_type(self, ast):
        return ast

    def exact_numeric_type(self, ast):
        return ast

    def precision(self, ast):
        return ast

    def scale(self, ast):
        return ast

    def approximate_numeric_type(self, ast):
        return ast

    def datetime_type(self, ast):
        return ast

    def time_precision(self, ast):
        return ast

    def time_fractional_seconds_precision(self, ast):
        return ast

    def timestamp_precision(self, ast):
        return ast

    def interval_type(self, ast):
        return ast

    def interval_qualifier(self, ast):
        return ast

    def start_field(self, ast):
        return ast

    def non_second_datetime_field(self, ast):
        return ast

    def interval_leading_field_precision(self, ast):
        return ast

    def end_field(self, ast):
        return ast

    def interval_fractional_seconds_precision(self, ast):
        return ast

    def single_datetime_field(self, ast):
        return ast

    def domain_name(self, ast):
        return ast

    def qualified_name(self, ast):
        return ast

    def default_clause(self, ast):
        return ast

    def default_option(self, ast):
        return ast

    def literal(self, ast):
        return ast

    def signed_numeric_literal(self, ast):
        return ast

    def general_literal(self, ast):
        return ast

    def datetime_literal(self, ast):
        return ast

    def date_literal(self, ast):
        return ast

    def time_literal(self, ast):
        return ast

    def timestamp_literal(self, ast):
        return ast

    def interval_literal(self, ast):
        return ast

    def datetime_value_function(self, ast):
        return ast

    def current_date_value_function(self, ast):
        return ast

    def current_time_value_function(self, ast):
        return ast

    def current_timestamp_value_function(self, ast):
        return ast

    def column_constraint_definition(self, ast):
        return ast

    def constraint_name_definition(self, ast):
        return ast

    def constraint_name(self, ast):
        return ast

    def column_constraint(self, ast):
        return ast

    def unique_specification(self, ast):
        return ast

    def references_specification(self, ast):
        return ast

    def referenced_table_and_columns(self, ast):
        return ast

    def table_name(self, ast):
        return ast

    def reference_column_list(self, ast):
        return ast

    def column_name_list(self, ast):
        return ast

    def match_type(self, ast):
        return ast

    def referential_triggered_action(self, ast):
        return ast

    def update_rule(self, ast):
        return ast

    def referential_action(self, ast):
        return ast

    def delete_rule(self, ast):
        return ast

    def check_constraint_definition(self, ast):
        return ast

    def search_condition(self, ast):
        return ast

    def boolean_term(self, ast):
        return ast

    def boolean_factor(self, ast):
        return ast

    def boolean_test(self, ast):
        return ast

    def boolean_primary(self, ast):
        return ast

    def predicate(self, ast):
        return ast

    def comparison_predicate(self, ast):
        return ast

    def row_value_constructor(self, ast):
        return ast

    def row_value_constructor_element(self, ast):
        return ast

    def value_expression(self, ast):
        return ast

    def numeric_value_expression(self, ast):
        return ast

    def term(self, ast):
        return ast

    def factor(self, ast):
        return ast

    def numeric_primary(self, ast):
        return ast

    def value_expression_primary(self, ast):
        return ast

    def unsigned_value_specification(self, ast):
        return ast

    def unsigned_literal(self, ast):
        return ast

    def general_value_specification(self, ast):
        return ast

    def parameter_specification(self, ast):
        return ast

    def parameter_name(self, ast):
        return ast

    def indicator_parameter(self, ast):
        return ast

    def dynamic_parameter_specification(self, ast):
        return ast

    def column_reference(self, ast):
        return ast

    def qualifier(self, ast):
        return ast

    def correlation_name(self, ast):
        return ast

    def set_function_specification(self, ast):
        return ast

    def general_set_function(self, ast):
        return ast

    def set_function_type(self, ast):
        return ast

    def set_quantifier(self, ast):
        return ast

    def scalar_subquery(self, ast):
        return ast

    def subquery(self, ast):
        return ast

    def query_expression(self, ast):
        return ast

    def non_join_query_expression(self, ast):
        return ast

    def non_join_query_term(self, ast):
        return ast

    def non_join_query_primary(self, ast):
        return ast

    def simple_table(self, ast):
        return ast

    def query_specification(self, ast):
        return ast

    def select_list(self, ast):
        return ast

    def select_sublist(self, ast):
        return ast

    def derived_column(self, ast):
        return ast

    def as_clause(self, ast):
        return ast

    def table_expression(self, ast):
        return ast

    def from_clause(self, ast):
        return ast

    def table_reference(self, ast):
        return ast

    def correlation_specification(self, ast):
        return ast

    def derived_column_list(self, ast):
        return ast

    def derived_table(self, ast):
        return ast

    def table_subquery(self, ast):
        return ast

    def joined_table(self, ast):
        return ast

    def cross_join(self, ast):
        return ast

    def qualified_join(self, ast):
        return ast

    def join_type(self, ast):
        return ast

    def outer_join_type(self, ast):
        return ast

    def join_specification(self, ast):
        return ast

    def join_condition(self, ast):
        return ast

    def named_columns_join(self, ast):
        return ast

    def join_column_list(self, ast):
        return ast

    def where_clause(self, ast):
        return ast

    def group_by_clause(self, ast):
        return ast

    def grouping_column_reference_list(self, ast):
        return ast

    def grouping_column_reference(self, ast):
        return ast

    def collate_clause(self, ast):
        return ast

    def collation_name(self, ast):
        return ast

    def having_clause(self, ast):
        return ast

    def table_value_constructor(self, ast):
        return ast

    def table_value_constructor_list(self, ast):
        return ast

    def explicit_table(self, ast):
        return ast

    def query_term(self, ast):
        return ast

    def corresponding_spec(self, ast):
        return ast

    def corresponding_column_list(self, ast):
        return ast

    def query_primary(self, ast):
        return ast

    def case_expression(self, ast):
        return ast

    def case_abbreviation(self, ast):
        return ast

    def case_specification(self, ast):
        return ast

    def simple_case(self, ast):
        return ast

    def case_operand(self, ast):
        return ast

    def simple_when_clause(self, ast):
        return ast

    def when_operand(self, ast):
        return ast

    def result(self, ast):
        return ast

    def result_expression(self, ast):
        return ast

    def else_clause(self, ast):
        return ast

    def searched_case(self, ast):
        return ast

    def searched_when_clause(self, ast):
        return ast

    def cast_specification(self, ast):
        return ast

    def cast_operand(self, ast):
        return ast

    def cast_target(self, ast):
        return ast

    def numeric_value_function(self, ast):
        return ast

    def position_expression(self, ast):
        return ast

    def character_value_expression(self, ast):
        return ast

    def concatenation(self, ast):
        return ast

    def character_factor(self, ast):
        return ast

    def character_primary(self, ast):
        return ast

    def string_value_function(self, ast):
        return ast

    def character_value_function(self, ast):
        return ast

    def character_substring_function(self, ast):
        return ast

    def start_position(self, ast):
        return ast

    def string_length(self, ast):
        return ast

    def fold(self, ast):
        return ast

    def form_of_use_conversion(self, ast):
        return ast

    def form_of_use_conversion_name(self, ast):
        return ast

    def character_translation(self, ast):
        return ast

    def translation_name(self, ast):
        return ast

    def trim_function(self, ast):
        return ast

    def trim_operands(self, ast):
        return ast

    def trim_specification(self, ast):
        return ast

    def trim_character(self, ast):
        return ast

    def trim_source(self, ast):
        return ast

    def bit_value_function(self, ast):
        return ast

    def bit_substring_function(self, ast):
        return ast

    def bit_value_expression(self, ast):
        return ast

    def bit_concatenation(self, ast):
        return ast

    def bit_factor(self, ast):
        return ast

    def bit_primary(self, ast):
        return ast

    def extract_expression(self, ast):
        return ast

    def extract_field(self, ast):
        return ast

    def datetime_field(self, ast):
        return ast

    def time_zone_field(self, ast):
        return ast

    def extract_source(self, ast):
        return ast

    def datetime_value_expression(self, ast):
        return ast

    def interval_term(self, ast):
        return ast

    def interval_factor(self, ast):
        return ast

    def interval_primary(self, ast):
        return ast

    def interval_term_2(self, ast):
        return ast

    def interval_value_expression(self, ast):
        return ast

    def interval_value_expression_1(self, ast):
        return ast

    def interval_term_1(self, ast):
        return ast

    def datetime_term(self, ast):
        return ast

    def datetime_factor(self, ast):
        return ast

    def datetime_primary(self, ast):
        return ast

    def time_zone(self, ast):
        return ast

    def time_zone_specifier(self, ast):
        return ast

    def length_expression(self, ast):
        return ast

    def char_length_expression(self, ast):
        return ast

    def string_value_expression(self, ast):
        return ast

    def octet_length_expression(self, ast):
        return ast

    def bit_length_expression(self, ast):
        return ast

    def null_specification(self, ast):
        return ast

    def default_specification(self, ast):
        return ast

    def row_value_constructor_list(self, ast):
        return ast

    def row_subquery(self, ast):
        return ast

    def comp_op(self, ast):
        return ast

    def between_predicate(self, ast):
        return ast

    def in_predicate(self, ast):
        return ast

    def in_predicate_value(self, ast):
        return ast

    def in_value_list(self, ast):
        return ast

    def like_predicate(self, ast):
        return ast

    def match_value(self, ast):
        return ast

    def pattern(self, ast):
        return ast

    def escape_character(self, ast):
        return ast

    def null_predicate(self, ast):
        return ast

    def quantified_comparison_predicate(self, ast):
        return ast

    def quantifier(self, ast):
        return ast

    def all(self, ast):
        return ast

    def some(self, ast):
        return ast

    def exists_predicate(self, ast):
        return ast

    def match_predicate(self, ast):
        return ast

    def overlaps_predicate(self, ast):
        return ast

    def row_value_constructor_1(self, ast):
        return ast

    def row_value_constructor_2(self, ast):
        return ast

    def truth_value(self, ast):
        return ast

    def constraint_attributes(self, ast):
        return ast

    def constraint_check_time(self, ast):
        return ast

    def table_constraint_definition(self, ast):
        return ast

    def table_constraint(self, ast):
        return ast

    def unique_constraint_definition(self, ast):
        return ast

    def unique_column_list(self, ast):
        return ast

    def referential_constraint_definition(self, ast):
        return ast

    def referencing_columns(self, ast):
        return ast

    def order_by_clause(self, ast):
        return ast

    def sort_specification_list(self, ast):
        return ast

    def sort_specification(self, ast):
        return ast

    def sort_key(self, ast):
        return ast

    def ordering_specification(self, ast):
        return ast

    def sql_schema_statement(self, ast):
        return ast

    def sql_schema_definition_statement(self, ast):
        return ast

    def schema_definition(self, ast):
        return ast

    def schema_name_clause(self, ast):
        return ast

    def schema_authorization_IDENTIFIER(self, ast):
        return ast

    def schema_character_set_specification(self, ast):
        return ast

    def schema_element(self, ast):
        return ast

    def domain_definition(self, ast):
        return ast

    def domain_constraint(self, ast):
        return ast

    def table_definition(self, ast):
        return ast

    def view_definition(self, ast):
        return ast

    def view_column_list(self, ast):
        return ast

    def levels_clause(self, ast):
        return ast

    def grant_statement(self, ast):
        return ast

    def privileges(self, ast):
        return ast

    def action_list(self, ast):
        return ast

    def action(self, ast):
        return ast

    def privilege_column_list(self, ast):
        return ast

    def object_name(self, ast):
        return ast

    def grantee(self, ast):
        return ast

    def assertion_definition(self, ast):
        return ast

    def assertion_check(self, ast):
        return ast

    def character_set_definition(self, ast):
        return ast

    def character_set_source(self, ast):
        return ast

    def limited_collation_definition(self, ast):
        return ast

    def collation_source(self, ast):
        return ast

    def collating_sequence_definition(self, ast):
        return ast

    def external_collation(self, ast):
        return ast

    def external_collation_name(self, ast):
        return ast

    def standard_collation_name(self, ast):
        return ast

    def implementation_defined_collation_name(self, ast):
        return ast

    def schema_collation_name(self, ast):
        return ast

    def translation_collation(self, ast):
        return ast

    def collation_definition(self, ast):
        return ast

    def pad_attribute(self, ast):
        return ast

    def translation_definition(self, ast):
        return ast

    def translation_source(self, ast):
        return ast

    def translation_specification(self, ast):
        return ast

    def external_translation(self, ast):
        return ast

    def external_translation_name(self, ast):
        return ast

    def standard_translation_name(self, ast):
        return ast

    def implementation_defined_translation_name(self, ast):
        return ast

    def schema_translation_name(self, ast):
        return ast

    def sql_schema_manipulation_statement(self, ast):
        return ast

    def drop_schema_statement(self, ast):
        return ast

    def drop_behaviour(self, ast):
        return ast

    def alter_table_statement(self, ast):
        return ast

    def alter_table_action(self, ast):
        return ast

    def add_column_definition(self, ast):
        return ast

    def alter_column_definition(self, ast):
        return ast

    def alter_column_action(self, ast):
        return ast

    def set_column_default_clause(self, ast):
        return ast

    def drop_column_default_clause(self, ast):
        return ast

    def drop_column_definition(self, ast):
        return ast

    def add_table_constraint_definition(self, ast):
        return ast

    def drop_table_constraint_definition(self, ast):
        return ast

    def drop_table_statement(self, ast):
        return ast

    def drop_view_statement(self, ast):
        return ast

    def revoke_statement(self, ast):
        return ast

    def alter_domain_statement(self, ast):
        return ast

    def alter_domain_action(self, ast):
        return ast

    def set_domain_default_clause(self, ast):
        return ast

    def drop_domain_default_clause(self, ast):
        return ast

    def add_domain_constraint_definition(self, ast):
        return ast

    def drop_domain_constraint_definition(self, ast):
        return ast

    def drop_domain_statement(self, ast):
        return ast

    def drop_character_set_statement(self, ast):
        return ast

    def drop_collation_statement(self, ast):
        return ast

    def drop_translation_statement(self, ast):
        return ast

    def drop_assertion_statement(self, ast):
        return ast

    def simple_value_specification(self, ast):
        return ast

    def delete_statement_searched(self, ast):
        return ast

    def insert_statement(self, ast):
        return ast

    def insert_columns_and_source(self, ast):
        return ast

    def insert_column_list(self, ast):
        return ast

    def set_clause_list(self, ast):
        return ast

    def set_clause(self, ast):
        return ast

    def object_column(self, ast):
        return ast

    def update_source(self, ast):
        return ast

    def update_statement_searched(self, ast):
        return ast

    def sql_transaction_statement(self, ast):
        return ast

    def set_transaction_statement(self, ast):
        return ast

    def transaction_mode(self, ast):
        return ast

    def isolation_level(self, ast):
        return ast

    def level_of_isolation(self, ast):
        return ast

    def transaction_access_mode(self, ast):
        return ast

    def diagnostics_size(self, ast):
        return ast

    def number_of_conditions(self, ast):
        return ast

    def set_constraints_mode_statement(self, ast):
        return ast

    def constraint_name_list(self, ast):
        return ast

    def commit_statement(self, ast):
        return ast

    def rollback_statement(self, ast):
        return ast

    def sql_connection_statement(self, ast):
        return ast

    def connect_statement(self, ast):
        return ast

    def connection_target(self, ast):
        return ast

    def sql_server_name(self, ast):
        return ast

    def connection_name(self, ast):
        return ast

    def user_name(self, ast):
        return ast

    def set_connection_statement(self, ast):
        return ast

    def connection_object(self, ast):
        return ast

    def disconnect_statement(self, ast):
        return ast

    def disconnect_object(self, ast):
        return ast

    def sql_session_statement(self, ast):
        return ast

    def set_catalog_statement(self, ast):
        return ast

    def value_specification(self, ast):
        return ast

    def set_schema_statement(self, ast):
        return ast

    def set_names_statement(self, ast):
        return ast

    def set_session_authorization_IDENTIFIER_statement(self, ast):
        return ast

    def set_local_time_zone_statement(self, ast):
        return ast

    def set_time_zone_value(self, ast):
        return ast

    def direct_sql_statement(self, ast):
        return ast

    def direct_sql_data_statement(self, ast):
        return ast

    def direct_select_statement_multiple_rows(self, ast):
        return ast


def main(
        filename,
        startrule,
        trace=False,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=True,
        left_recursion=True,
        **kwargs):

    with open(filename) as f:
        text = f.read()
    whitespace = whitespace or None
    parser = SqlParser(parseinfo=False)
    ast = parser.parse(
        text,
        startrule,
        filename=filename,
        trace=trace,
        whitespace=whitespace,
        nameguard=nameguard,
        ignorecase=ignorecase,
        **kwargs)
    return ast

if __name__ == '__main__':
    import json
    ast = generic_main(main, SqlParser, name='Sql')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()