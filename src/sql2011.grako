# The MIT License (MIT)
# Copyright (c) 2016, Victor M. Uriarte
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

@@grammar :: Sql
@@ignorecase :: True

@@whitespace :: /\s+/
@@eol_comments :: /--.*?$/
@@comments :: ?//\*[\s\S]*?\*//?
@@keyword :: SELECT FROM WHERE


start =
    direct_sql_statement $
    ;

# 5 Lexical elements

# 5.1 sql_terminal_character

# Function
# Define the terminal symbols of the SQL language and the elements of strings.

# Format
sql_terminal_character =
    sql_language_character
    ;

sql_language_character =
    simple_latin_letter
  | digit
  | sql_special_character
    ;

simple_latin_letter =
    /[a-z]/
    ;

digit =
    /\d/
    ;

sql_special_character =
    space
  | double_quote
  | percent
  | ampersand
  | quote
  | left_paren
  | right_paren
  | asterisk
  | plus_sign
  | comma
  | minus_sign
  | period
  | solidus
  | colon
  | semicolon
  | less_than_operator
  | equals_operator
  | greater_than_operator
  | question_mark
  | left_bracket
  | right_bracket
  | circumflex
  | underscore
  | vertical_bar
  | left_brace
  | right_brace
    ;

# SEE_SYNTAX_RULES
space =
    ' '
    ;

double_quote =
    '"'
    ;

percent =
    '%'
    ;

ampersand =
    '&'
    ;

quote =
    "'"
    ;

left_paren =
    '('
    ;

right_paren =
    ')'
    ;

asterisk =
    '*'
    ;

plus_sign =
    '+'
    ;

comma =
    ','
    ;

minus_sign =
    '-'
    ;

period =
    '.'
    ;

solidus =
    '/'
    ;

reverse_solidus =
    '\'
    ;

colon =
    ':'
    ;

semicolon =
    ';'
    ;

less_than_operator =
    '<'
    ;

equals_operator =
    '='
    ;

greater_than_operator =
    '>'
    ;

question_mark =
    '?'
    ;

left_bracket_or_trigraph =
    left_bracket
  | left_bracket_trigraph
    ;

right_bracket_or_trigraph =
    right_bracket
  | right_bracket_trigraph
    ;

left_bracket =
    '['
    ;

left_bracket_trigraph =
    '??('
    ;

right_bracket =
    ']'
    ;

right_bracket_trigraph =
    '??)'
    ;

circumflex =
    '^'
    ;

underscore =
    '_'
    ;

vertical_bar =
    '|'
    ;

left_brace =
    '{'
    ;

right_brace =
    '}'
    ;

# 5.2 token and separator

# Function
# Specify lexical units (tokens and separators) that participate in SQL
# language.

# Format
token =
    nondelimiter_token
  | delimiter_token
    ;

nondelimiter_token =
    regular_identifier
  | keyword
  | unsigned_numeric_literal
  | national_character_string_literal
  | binary_string_literal
  | large_object_length_token
  | unicode_delimited_identifier
  | unicode_character_string_literal
  | sql_language_identifier
    ;

regular_identifier =
    identifier_body
    ;

identifier_body =
    identifier_start [{identifier_part}+]
    ;

identifier_part =
    identifier_start
  | identifier_extend
    ;

# SEE_SYNTAX_RULES
identifier_start =
    simple_latin_letter
    ;

# SEE_SYNTAX_RULES
identifier_extend =
    /\w/
    ;

large_object_length_token =
    {digit}+ multiplier
    ;

multiplier =
    'K'
  | 'M'
  | 'G'
  | 'T'
  | 'P'
    ;

delimited_identifier =
    double_quote delimited_identifier_body double_quote
    ;

delimited_identifier_body =
    {delimited_identifier_part}+
    ;

delimited_identifier_part =
    nondoublequote_character
  | doublequote_symbol
    ;

unicode_delimited_identifier =
    'U' ampersand double_quote unicode_delimiter_body double_quote
        unicode_escape_specifier
    ;

unicode_escape_specifier =
    ['UESCAPE' quote unicode_escape_character quote]
    ;

unicode_delimiter_body =
    {unicode_identifier_part}+
    ;

unicode_identifier_part =
    delimited_identifier_part
  | unicode_escape_value
    ;

unicode_escape_value =
    unicode_4_digit_escape_value
  | unicode_6_digit_escape_value
  | unicode_character_escape_value
    ;

unicode_4_digit_escape_value =
    unicode_escape_character hexit hexit hexit hexit
    ;

unicode_6_digit_escape_value =
    unicode_escape_character plus_sign
        hexit hexit hexit hexit hexit hexit
    ;

unicode_character_escape_value =
    unicode_escape_character unicode_escape_character
    ;

# SEE_SYNTAX_RULES
unicode_escape_character =
    '\U'
    ;

# SEE_SYNTAX_RULES
nondoublequote_character =
    /[^"\n]/
    ;

# SEE_SYNTAX_RULES
doublequote_symbol =
    '""'
    ;

delimiter_token =
    character_string_literal
  | date_string
  | time_string
  | timestamp_string
  | interval_string
  | delimited_identifier
  | sql_special_character
  | not_equals_operator
  | greater_than_or_equals_operator
  | less_than_or_equals_operator
  | concatenation_operator
  | right_arrow
  | left_bracket_trigraph
  | right_bracket_trigraph
  | double_colon
  | double_period
  | named_argument_assignment_token
    ;

not_equals_operator =
    '<>'
    ;

greater_than_or_equals_operator =
    '>='
    ;

less_than_or_equals_operator =
    '<='
    ;

concatenation_operator =
    '||'
    ;

right_arrow =
    '->'
    ;

double_colon =
    '::'
    ;

double_period =
    '..'
    ;

named_argument_assignment_token =
    '=>'
    ;

separator =
    {comment | whitespace}+
    ;

# SEE_SYNTAX_RULES
whitespace =
    /\s/
    ;

comment =
    simple_comment
  | bracketed_comment
    ;

simple_comment =
    simple_comment_introducer [{comment_character}+] newline
    ;

simple_comment_introducer =
    minus_sign minus_sign
    ;

bracketed_comment =
    bracketed_comment_introducer
        bracketed_comment_contents
        bracketed_comment_terminator
    ;

bracketed_comment_introducer =
    '/*'
    ;

bracketed_comment_terminator =
    '*/'
    ;

# SEE_SYNTAX_RULES
bracketed_comment_contents =
    [{comment_character | separator}+]
    ;

comment_character =
    nonquote_character
  | quote
    ;

# SEE_SYNTAX_RULES
newline =
    /\n/
    ;

keyword =
    reserved_word
  | non_reserved_word
    ;

non_reserved_word =
    'A'
  | 'ABSOLUTE'
  | 'ACTION'
  | 'ADA'
  | 'ADD'
  | 'ADMIN'
  | 'AFTER'
  | 'ALWAYS'
  | 'ASC'
  | 'ASSERTION'
  | 'ASSIGNMENT'
  | 'ATTRIBUTE'
  | 'ATTRIBUTES'

  | 'BEFORE'
  | 'BERNOULLI'
  | 'BREADTH'

  | 'C'
  | 'CASCADE'
  | 'CATALOG'
  | 'CATALOG_NAME'
  | 'CHAIN'
  | 'CHARACTER_SET_CATALOG'
  | 'CHARACTER_SET_NAME'
  | 'CHARACTER_SET_SCHEMA'
  | 'CHARACTERISTICS'
  | 'CHARACTERS'
  | 'CLASS_ORIGIN'
  | 'COBOL'
  | 'COLLATION'
  | 'COLLATION_CATALOG'
  | 'COLLATION_NAME'
  | 'COLLATION_SCHEMA'
  | 'COLUMN_NAME'
  | 'COMMAND_FUNCTION'
  | 'COMMAND_FUNCTION_CODE'
  | 'COMMITTED'
  | 'CONDITION_NUMBER'
  | 'CONNECTION'
  | 'CONNECTION_NAME'
  | 'CONSTRAINT_CATALOG'
  | 'CONSTRAINT_NAME'
  | 'CONSTRAINT_SCHEMA'
  | 'CONSTRAINTS'
  | 'CONSTRUCTOR'
  | 'CONTINUE'
  | 'CURSOR_NAME'

  | 'DATA'
  | 'DATETIME_INTERVAL_CODE'
  | 'DATETIME_INTERVAL_PRECISION'
  | 'DEFAULTS'
  | 'DEFERRABLE'
  | 'DEFERRED'
  | 'DEFINED'
  | 'DEFINER'
  | 'DEGREE'
  | 'DEPTH'
  | 'DERIVED'
  | 'DESC'
  | 'DESCRIPTOR'
  | 'DIAGNOSTICS'
  | 'DISPATCH'
  | 'DOMAIN'
  | 'DYNAMIC_FUNCTION'
  | 'DYNAMIC_FUNCTION_CODE'

  | 'ENFORCED'
  | 'EXCLUDE'
  | 'EXCLUDING'
  | 'EXPRESSION'

  | 'FINAL'
  | 'FIRST'
  | 'FLAG'
  | 'FOLLOWING'
  | 'FORTRAN'
  | 'FOUND'

  | 'G'
  | 'GENERAL'
  | 'GENERATED'
  | 'GO'
  | 'GOTO'
  | 'GRANTED'

  | 'HIERARCHY'

  | 'IGNORE'
  | 'IMMEDIATE'
  | 'IMMEDIATELY'
  | 'IMPLEMENTATION'
  | 'INCLUDING'
  | 'INCREMENT'
  | 'INITIALLY'
  | 'INPUT'
  | 'INSTANCE'
  | 'INSTANTIABLE'
  | 'INSTEAD'
  | 'INVOKER'
  | 'ISOLATION'

  | 'K'
  | 'KEY'
  | 'KEY_MEMBER'
  | 'KEY_TYPE'

  | 'LAST'
  | 'LENGTH'
  | 'LEVEL'
  | 'LOCATOR'

  | 'M'
  | 'MAP'
  | 'MATCHED'
  | 'MAXVALUE'
  | 'MESSAGE_LENGTH'
  | 'MESSAGE_OCTET_LENGTH'
  | 'MESSAGE_TEXT'
  | 'MINVALUE'
  | 'MORE'
  | 'MUMPS'

  | 'NAME'
  | 'NAMES'
  | 'NESTING'
  | 'NEXT'
  | 'NFC'
  | 'NFD'
  | 'NFKC'
  | 'NFKD'
  | 'NORMALIZED'
  | 'NULLABLE'
  | 'NULLS'
  | 'NUMBER'

  | 'OBJECT'
  | 'OCTETS'
  | 'OPTION'
  | 'OPTIONS'
  | 'ORDERING'
  | 'ORDINALITY'
  | 'OTHERS'
  | 'OUTPUT'
  | 'OVERRIDING'

  | 'P'
  | 'PAD'
  | 'PARAMETER_MODE'
  | 'PARAMETER_NAME'
  | 'PARAMETER_ORDINAL_POSITION'
  | 'PARAMETER_SPECIFIC_CATALOG'
  | 'PARAMETER_SPECIFIC_NAME'
  | 'PARAMETER_SPECIFIC_SCHEMA'
  | 'PARTIAL'
  | 'PASCAL'
  | 'PATH'
  | 'PLACING'
  | 'PLI'
  | 'PRECEDING'
  | 'PRESERVE'
  | 'PRIOR'
  | 'PRIVILEGES'
  | 'PUBLIC'

  | 'READ'
  | 'RELATIVE'
  | 'REPEATABLE'
  | 'RESPECT'
  | 'RESTART'
  | 'RESTRICT'
  | 'RETURNED_CARDINALITY'
  | 'RETURNED_LENGTH'
  | 'RETURNED_OCTET_LENGTH'
  | 'RETURNED_SQLSTATE'
  | 'ROLE'
  | 'ROUTINE'
  | 'ROUTINE_CATALOG'
  | 'ROUTINE_NAME'
  | 'ROUTINE_SCHEMA'
  | 'ROW_COUNT'
  | 'SCALE'
  | 'SCHEMA'
  | 'SCHEMA_NAME'
  | 'SCOPE_CATALOG'
  | 'SCOPE_NAME'
  | 'SCOPE_SCHEMA'
  | 'SECTION'
  | 'SECURITY'
  | 'SELF'
  | 'SEQUENCE'
  | 'SERIALIZABLE'
  | 'SERVER_NAME'
  | 'SESSION'
  | 'SETS'
  | 'SIMPLE'
  | 'SIZE'
  | 'SOURCE'
  | 'SPACE'
  | 'SPECIFIC_NAME'
  | 'STATE'
  | 'STATEMENT'
  | 'STRUCTURE'
  | 'STYLE'
  | 'SUBCLASS_ORIGIN'

  | 'T'
  | 'TABLE_NAME'
  | 'TEMPORARY'
  | 'TIES'
  | 'TOP_LEVEL_COUNT'
  | 'TRANSACTION'
  | 'TRANSACTION_ACTIVE'
  | 'TRANSACTIONS_COMMITTED'
  | 'TRANSACTIONS_ROLLED_BACK'
  | 'TRANSFORM'
  | 'TRANSFORMS'
  | 'TRIGGER_CATALOG'
  | 'TRIGGER_NAME'
  | 'TRIGGER_SCHEMA'
  | 'TYPE'

  | 'UNBOUNDED'
  | 'UNCOMMITTED'
  | 'UNDER'
  | 'UNNAMED'
  | 'USAGE'
  | 'USER_DEFINED_TYPE_CATALOG'
  | 'USER_DEFINED_TYPE_CODE'
  | 'USER_DEFINED_TYPE_NAME'
  | 'USER_DEFINED_TYPE_SCHEMA'

  | 'VIEW'

  | 'WORK'
  | 'WRITE'

  | 'ZONE'
    ;

reserved_word =
    'ABS'
  | 'ALL'
  | 'ALLOCATE'
  | 'ALTER'
  | 'AND'
  | 'ANY'
  | 'ARE'
  | 'ARRAY'
  | 'ARRAY_AGG'
  | 'ARRAY_MAX_CARDINALITY'
  | 'AS'
  | 'ASENSITIVE'
  | 'ASYMMETRIC'
  | 'AT'
  | 'ATOMIC'
  | 'AUTHORIZATION'
  | 'AVG'

  | 'BEGIN'
  | 'BEGIN_FRAME'
  | 'BEGIN_PARTITION'
  | 'BETWEEN'
  | 'BIGINT'
  | 'BINARY'
  | 'BLOB'
  | 'BOOLEAN'
  | 'BOTH'
  | 'BY'

  | 'CALL'
  | 'CALLED'
  | 'CARDINALITY'
  | 'CASCADED'
  | 'CASE'
  | 'CAST'
  | 'CEIL'
  | 'CEILING'
  | 'CHAR'
  | 'CHAR_LENGTH'
  | 'CHARACTER'
  | 'CHARACTER_LENGTH'
  | 'CHECK'
  | 'CLOB'
  | 'CLOSE'
  | 'COALESCE'
  | 'COLLATE'
  | 'COLLECT'
  | 'COLUMN'
  | 'COMMIT'
  | 'CONDITION'
  | 'CONNECT'
  | 'CONSTRAINT'
  | 'CONTAINS'
  | 'CONVERT'
  | 'CORR'
  | 'CORRESPONDING'
  | 'COUNT'
  | 'COVAR_POP'
  | 'COVAR_SAMP'
  | 'CREATE'
  | 'CROSS'
  | 'CUBE'
  | 'CUME_DIST'
  | 'CURRENT'
  | 'CURRENT_CATALOG'
  | 'CURRENT_DATE'
  | 'CURRENT_DEFAULT_TRANSFORM_GROUP'
  | 'CURRENT_PATH'
  | 'CURRENT_ROLE'
  | 'CURRENT_ROW'
  | 'CURRENT_SCHEMA'
  | 'CURRENT_TIME'
  | 'CURRENT_TIMESTAMP'
  | 'CURRENT_TRANSFORM_GROUP_FOR_TYPE'
  | 'CURRENT_USER'
  | 'CURSOR'
  | 'CYCLE'

  | 'DATE'
  | 'DAY'
  | 'DEALLOCATE'
  | 'DEC'
  | 'DECIMAL'
  | 'DECLARE'
  | 'DEFAULT'
  | 'DELETE'
  | 'DENSE_RANK'
  | 'DEREF'
  | 'DESCRIBE'
  | 'DETERMINISTIC'
  | 'DISCONNECT'
  | 'DISTINCT'
  | 'DOUBLE'
  | 'DROP'
  | 'DYNAMIC'

  | 'EACH'
  | 'ELEMENT'
  | 'ELSE'
  | 'END'
  | 'END_FRAME'
  | 'END_PARTITION'
  | 'END-EXEC'
  | 'EQUALS'
  | 'ESCAPE'
  | 'EVERY'
  | 'EXCEPT'
  | 'EXEC'
  | 'EXECUTE'
  | 'EXISTS'
  | 'EXP'
  | 'EXTERNAL'
  | 'EXTRACT'

  | 'FALSE'
  | 'FETCH'
  | 'FILTER'
  | 'FIRST_VALUE'
  | 'FLOAT'
  | 'FLOOR'
  | 'FOR'
  | 'FOREIGN'
  | 'FRAME_ROW'
  | 'FREE'
  | 'FROM'
  | 'FULL'
  | 'FUNCTION'
  | 'FUSION'

  | 'GET'
  | 'GLOBAL'
  | 'GRANT'
  | 'GROUP'
  | 'GROUPING'
  | 'GROUPS'

  | 'HAVING'
  | 'HOLD'
  | 'HOUR'

  | 'IDENTITY'
  | 'IN'
  | 'INDICATOR'
  | 'INNER'
  | 'INOUT'
  | 'INSENSITIVE'
  | 'INSERT'
  | 'INT'
  | 'INTEGER'
  | 'INTERSECT'
  | 'INTERSECTION'
  | 'INTERVAL'
  | 'INTO'
  | 'IS'

  | 'JOIN'

  | 'LAG'
  | 'LANGUAGE'
  | 'LARGE'
  | 'LAST_VALUE'
  | 'LATERAL'
  | 'LEAD'
  | 'LEADING'
  | 'LEFT'
  | 'LIKE'
  | 'LIKE_REGEX'
  | 'LN'
  | 'LOCAL'
  | 'LOCALTIME'
  | 'LOCALTIMESTAMP'
  | 'LOWER'

  | 'MATCH'
  | 'MAX'
  | 'MEMBER'
  | 'MERGE'
  | 'METHOD'
  | 'MIN'
  | 'MINUTE'
  | 'MOD'
  | 'MODIFIES'
  | 'MODULE'
  | 'MONTH'
  | 'MULTISET'

  | 'NATIONAL'
  | 'NATURAL'
  | 'NCHAR'
  | 'NCLOB'
  | 'NEW'
  | 'NO'
  | 'NONE'
  | 'NORMALIZE'
  | 'NOT'
  | 'NTH_VALUE'
  | 'NTILE'
  | 'NULL'
  | 'NULLIF'
  | 'NUMERIC'

  | 'OCTET_LENGTH'
  | 'OCCURRENCES_REGEX'
  | 'OF'
  | 'OFFSET'
  | 'OLD'
  | 'ON'
  | 'ONLY'
  | 'OPEN'
  | 'OR'
  | 'ORDER'
  | 'OUT'
  | 'OUTER'
  | 'OVER'
  | 'OVERLAPS'
  | 'OVERLAY'

  | 'PARAMETER'
  | 'PARTITION'
  | 'PERCENT'
  | 'PERCENT_RANK'
  | 'PERCENTILE_CONT'
  | 'PERCENTILE_DISC'
  | 'PERIOD'
  | 'PORTION'
  | 'POSITION'
  | 'POSITION_REGEX'
  | 'POWER'
  | 'PRECEDES'
  | 'PRECISION'
  | 'PREPARE'
  | 'PRIMARY'
  | 'PROCEDURE'

  | 'RANGE'
  | 'RANK'
  | 'READS'
  | 'REAL'
  | 'RECURSIVE'
  | 'REF'
  | 'REFERENCES'
  | 'REFERENCING'
  | 'REGR_AVGX'
  | 'REGR_AVGY'
  | 'REGR_COUNT'
  | 'REGR_INTERCEPT'
  | 'REGR_R2'
  | 'REGR_SLOPE'
  | 'REGR_SXX'
  | 'REGR_SXY'
  | 'REGR_SYY'
  | 'RELEASE'
  | 'RESULT'
  | 'RETURN'
  | 'RETURNS'
  | 'REVOKE'
  | 'RIGHT'
  | 'ROLLBACK'
  | 'ROLLUP'
  | 'ROW'
  | 'ROW_NUMBER'
  | 'ROWS'

  | 'SAVEPOINT'
  | 'SCOPE'
  | 'SCROLL'
  | 'SEARCH'
  | 'SECOND'
  | 'SELECT'
  | 'SENSITIVE'
  | 'SESSION_USER'
  | 'SET'
  | 'SIMILAR'
  | 'SMALLINT'
  | 'SOME'
  | 'SPECIFIC'
  | 'SPECIFICTYPE'
  | 'SQL'
  | 'SQLEXCEPTION'
  | 'SQLSTATE'
  | 'SQLWARNING'
  | 'SQRT'
  | 'START'
  | 'STATIC'
  | 'STDDEV_POP'
  | 'STDDEV_SAMP'
  | 'SUBMULTISET'
  | 'SUBSTRING'
  | 'SUBSTRING_REGEX'
  | 'SUCCEEDS'
  | 'SUM'
  | 'SYMMETRIC'
  | 'SYSTEM'
  | 'SYSTEM_TIME'
  | 'SYSTEM_USER'

  | 'TABLE'
  | 'TABLESAMPLE'
  | 'THEN'
  | 'TIME'
  | 'TIMESTAMP'
  | 'TIMEZONE_HOUR'
  | 'TIMEZONE_MINUTE'
  | 'TO'
  | 'TRAILING'
  | 'TRANSLATE'
  | 'TRANSLATE_REGEX'
  | 'TRANSLATION'
  | 'TREAT'
  | 'TRIGGER'
  | 'TRUNCATE'
  | 'TRIM'
  | 'TRIM_ARRAY'
  | 'TRUE'

  | 'UESCAPE'
  | 'UNION'
  | 'UNIQUE'
  | 'UNKNOWN'
  | 'UNNEST'
  | 'UPDATE'
  | 'UPPER'
  | 'USER'
  | 'USING'

  | 'VALUE'
  | 'VALUES'
  | 'VALUE_OF'
  | 'VAR_POP'
  | 'VAR_SAMP'
  | 'VARBINARY'
  | 'VARCHAR'
  | 'VARYING'
  | 'VERSIONING'

  | 'WHEN'
  | 'WHENEVER'
  | 'WHERE'
  | 'WIDTH_BUCKET'
  | 'WINDOW'
  | 'WITH'
  | 'WITHIN'
  | 'WITHOUT'

  | 'YEAR'
    ;

# 5.3 literal

# Function
# Specify a non-null value.

# Format
literal =
    signed_numeric_literal
  | general_literal
    ;

unsigned_literal =
    unsigned_numeric_literal
  | general_literal
    ;

general_literal =
    character_string_literal
  | national_character_string_literal
  | unicode_character_string_literal
  | binary_string_literal
  | datetime_literal
  | interval_literal
  | boolean_literal
    ;

character_string_literal =
    [introducer character_set_specification]
        (separator).{quote [{character_representation}+] quote}
    ;

introducer =
    underscore
    ;

character_representation =
    nonquote_character
  | quote_symbol
    ;

# SEE_SYNTAX_RULES
nonquote_character =
    /[^'\n]/
    ;

quote_symbol =
    quote quote
    ;

national_character_string_literal =
    'N' (separator).{quote [{character_representation}+] quote}
    ;

unicode_character_string_literal =
    [introducer character_set_specification]
        'U' ampersand (separator).{quote [{unicode_representation}+] quote}
        unicode_escape_specifier
    ;

unicode_representation =
    character_representation
  | unicode_escape_value
    ;

binary_string_literal =
    'X' (separator).{quote [{space}+] [{hexit [{space}+] hexit [{space}+]}+] quote}
    ;

hexit =
    /[a-f\d]/
    ;

signed_numeric_literal =
    [sign] unsigned_numeric_literal
    ;

unsigned_numeric_literal =
    exact_numeric_literal
  | approximate_numeric_literal
    ;

exact_numeric_literal =
    unsigned_integer [period [unsigned_integer]]
  | period unsigned_integer
    ;

sign =
    plus_sign
  | minus_sign
    ;

approximate_numeric_literal =
    mantissa 'E' exponent
    ;

mantissa =
    exact_numeric_literal
    ;

exponent =
    signed_integer
    ;

signed_integer =
    [sign] unsigned_integer
    ;

unsigned_integer =
    {digit}+
    ;

datetime_literal =
    date_literal
  | time_literal
  | timestamp_literal
    ;

date_literal =
    'DATE' date_string
    ;

time_literal =
    'TIME' time_string
    ;

timestamp_literal =
    'TIMESTAMP' timestamp_string
    ;

date_string =
    quote unquoted_date_string quote
    ;

time_string =
    quote unquoted_time_string quote
    ;

timestamp_string =
    quote unquoted_timestamp_string quote
    ;

time_zone_interval =
    sign hours_value colon minutes_value
    ;

date_value =
    years_value minus_sign months_value minus_sign days_value
    ;

time_value =
    hours_value colon minutes_value colon seconds_value
    ;

interval_literal =
    'INTERVAL' [sign] interval_string interval_qualifier
    ;

interval_string =
    quote unquoted_interval_string quote
    ;

unquoted_date_string =
    date_value
    ;

unquoted_time_string =
    time_value [time_zone_interval]
    ;

unquoted_timestamp_string =
    unquoted_date_string space unquoted_time_string
    ;

unquoted_interval_string =
    [sign] (year_month_literal | day_time_literal)
    ;

year_month_literal =
    years_value [minus_sign months_value]
  | months_value
    ;

day_time_literal =
    day_time_interval
  | time_interval
    ;

day_time_interval =
    days_value [space hours_value [colon minutes_value [colon seconds_value]]]
    ;

time_interval =
    hours_value [colon minutes_value [colon seconds_value]]
  | minutes_value [colon seconds_value]
  | seconds_value
    ;

years_value =
    datetime_value
    ;

months_value =
    datetime_value
    ;

days_value =
    datetime_value
    ;

hours_value =
    datetime_value
    ;

minutes_value =
    datetime_value
    ;

seconds_value =
    seconds_integer_value [period [seconds_fraction]]
    ;

seconds_integer_value =
    unsigned_integer
    ;

seconds_fraction =
    unsigned_integer
    ;

datetime_value =
    unsigned_integer
    ;

boolean_literal =
    'TRUE'
  | 'FALSE'
  | 'UNKNOWN'
    ;

# 5.4 Names and identifiers

# Function
# Specify names.

# Format
identifier =
    actual_identifier
    ;

actual_identifier =
    regular_identifier
  | delimited_identifier
  | unicode_delimited_identifier
    ;

sql_language_identifier =
    sql_language_identifier_start [{sql_language_identifier_part}+]
    ;

sql_language_identifier_start =
    simple_latin_letter
    ;

sql_language_identifier_part =
    simple_latin_letter
  | digit
  | underscore
    ;

authorization_identifier =
    role_name
  | user_identifier
    ;

table_name =
    local_or_schema_qualified_name
    ;

domain_name =
    schema_qualified_name
    ;

schema_name =
    [catalog_name period] unqualified_schema_name
    ;

unqualified_schema_name =
    identifier
    ;

catalog_name =
    identifier
    ;

schema_qualified_name =
    [schema_name period] qualified_identifier
    ;

local_or_schema_qualified_name =
    [local_or_schema_qualifier period] qualified_identifier
    ;

local_or_schema_qualifier =
    schema_name
  | local_qualifier
    ;

qualified_identifier =
    identifier
    ;

column_name =
    identifier
    ;

correlation_name =
    identifier
    ;

query_name =
    identifier
    ;

sql_client_module_name =
    identifier
    ;

procedure_name =
    identifier
    ;

schema_qualified_routine_name =
    schema_qualified_name
    ;

method_name =
    identifier
    ;

specific_name =
    schema_qualified_name
    ;

cursor_name =
    local_qualified_name
    ;

local_qualified_name =
    [local_qualifier period] qualified_identifier
    ;

local_qualifier =
    'MODULE'
    ;

host_parameter_name =
    colon identifier
    ;

sql_parameter_name =
    identifier
    ;

constraint_name =
    schema_qualified_name
    ;

external_routine_name =
    identifier
  | character_string_literal
    ;

trigger_name =
    schema_qualified_name
    ;

collation_name =
    schema_qualified_name
    ;

character_set_name =
    [schema_name period] sql_language_identifier
    ;

transliteration_name =
    schema_qualified_name
    ;

transcoding_name =
    schema_qualified_name
    ;

schema_resolved_user_defined_type_name =
    user_defined_type_name
    ;

user_defined_type_name =
    [schema_name period] qualified_identifier
    ;

attribute_name =
    identifier
    ;

field_name =
    identifier
    ;

savepoint_name =
    identifier
    ;

sequence_generator_name =
    schema_qualified_name
    ;

role_name =
    identifier
    ;

user_identifier =
    identifier
    ;

connection_name =
    simple_value_specification
    ;

sql_server_name =
    simple_value_specification
    ;

connection_user_name =
    simple_value_specification
    ;

sql_statement_name =
    statement_name
  | extended_statement_name
    ;

statement_name =
    identifier
    ;

extended_statement_name =
    [scope_option] simple_value_specification
    ;

dynamic_cursor_name =
    cursor_name
  | extended_cursor_name
    ;

extended_cursor_name =
    [scope_option] simple_value_specification
    ;

descriptor_name =
    non_extended_descriptor_name
  | extended_descriptor_name
    ;

non_extended_descriptor_name =
    identifier
    ;

extended_descriptor_name =
    [scope_option] simple_value_specification
    ;

scope_option =
    'GLOBAL'
  | 'LOCAL'
    ;

window_name =
    identifier
    ;

# 6 Scalar expressions

# 6.1 data_type

# Function
# Specify a data type.

# Format
data_type =
    predefined_type
  | row_type
  | path_resolved_user_defined_type_name
  | reference_type
  | collection_type
    ;

predefined_type =
    character_string_type ['CHARACTER' 'SET' character_set_specification] [collate_clause]
  | national_character_string_type [collate_clause]
  | binary_string_type
  | numeric_type
  | boolean_type
  | datetime_type
  | interval_type
    ;

character_string_type =
    'CHARACTER' [left_paren character_length right_paren]
  | 'CHAR' [left_paren character_length right_paren]
  | 'CHARACTER' 'VARYING' left_paren character_length right_paren
  | 'CHAR' 'VARYING' left_paren character_length right_paren
  | 'VARCHAR' left_paren character_length right_paren
  | character_large_object_type
    ;

character_large_object_type =
    'CHARACTER' 'LARGE' 'OBJECT' [left_paren character_large_object_length right_paren]
  | 'CHAR' 'LARGE' 'OBJECT' [left_paren character_large_object_length right_paren]
  | 'CLOB' [left_paren character_large_object_length right_paren]
    ;

national_character_string_type =
    'NATIONAL' 'CHARACTER' [left_paren character_length right_paren]
  | 'NATIONAL' 'CHAR' [left_paren character_length right_paren]
  | 'NCHAR' [left_paren character_length right_paren]
  | 'NATIONAL' 'CHARACTER' 'VARYING' left_paren character_length right_paren
  | 'NATIONAL' 'CHAR' 'VARYING' left_paren character_length right_paren
  | 'NCHAR' 'VARYING' left_paren character_length right_paren
  | national_character_large_object_type
    ;

national_character_large_object_type =
    'NATIONAL' 'CHARACTER' 'LARGE' 'OBJECT' [left_paren character_large_object_length right_paren]
  | 'NCHAR' 'LARGE' 'OBJECT' [left_paren character_large_object_length right_paren]
  | 'NCLOB' [left_paren character_large_object_length right_paren]
    ;

binary_string_type =
    'BINARY' [left_paren length right_paren]
  | 'BINARY' 'VARYING' left_paren length right_paren
  | 'VARBINARY' left_paren length right_paren
  | binary_large_object_string_type
    ;

binary_large_object_string_type =
    'BINARY' 'LARGE' 'OBJECT' [left_paren large_object_length right_paren]
  | 'BLOB' [left_paren large_object_length right_paren]
    ;

numeric_type =
    exact_numeric_type
  | approximate_numeric_type
    ;

exact_numeric_type =
    'NUMERIC' [left_paren precision [comma scale] right_paren]
  | 'DECIMAL' [left_paren precision [comma scale] right_paren]
  | 'DEC' [left_paren precision [comma scale] right_paren]
  | 'SMALLINT'
  | 'INTEGER'
  | 'INT'
  | 'BIGINT'
    ;

approximate_numeric_type =
    'FLOAT' [left_paren precision right_paren]
  | 'REAL'
  | 'DOUBLE' 'PRECISION'
    ;

length =
    unsigned_integer
    ;

character_length =
    length [char_length_units]
    ;

large_object_length =
    length [multiplier]
  | large_object_length_token
    ;

character_large_object_length =
    large_object_length [char_length_units]
    ;

char_length_units =
    'CHARACTERS'
  | 'OCTETS'
    ;

precision =
    unsigned_integer
    ;

scale =
    unsigned_integer
    ;

boolean_type =
    'BOOLEAN'
    ;

datetime_type =
    'DATE'
  | 'TIME' [left_paren time_precision right_paren] [with_or_without_time_zone]
  | 'TIMESTAMP' [left_paren timestamp_precision right_paren]
        [with_or_without_time_zone]
    ;

with_or_without_time_zone =
    'WITH' 'TIME' 'ZONE'
  | 'WITHOUT' 'TIME' 'ZONE'
    ;

time_precision =
    time_fractional_seconds_precision
    ;

timestamp_precision =
    time_fractional_seconds_precision
    ;

time_fractional_seconds_precision =
    unsigned_integer
    ;

interval_type =
    'INTERVAL' interval_qualifier
    ;

row_type =
    'ROW' row_type_body
    ;

row_type_body =
    left_paren ','.{field_definition} right_paren
    ;

reference_type =
    'REF' left_paren referenced_type right_paren [scope_clause]
    ;

scope_clause =
    'SCOPE' table_name
    ;

referenced_type =
    path_resolved_user_defined_type_name
    ;

path_resolved_user_defined_type_name =
    user_defined_type_name
    ;

collection_type =
    array_type
  | multiset_type
    ;

array_type =
    data_type 'ARRAY'
        [left_bracket_or_trigraph maximum_cardinality right_bracket_or_trigraph]
    ;

maximum_cardinality =
    unsigned_integer
    ;

multiset_type =
    data_type 'MULTISET'
    ;

# 6.2 field_definition

# Function
# Define a field of a row type.

# Format
field_definition =
    field_name data_type
    ;

# 6.3 value_expression_primary

# Function
# Specify a value that is syntactically self-delimited.

# Format
value_expression_primary =
    parenthesized_value_expression
  | nonparenthesized_value_expression_primary
    ;

parenthesized_value_expression =
    left_paren value_expression right_paren
    ;

nonparenthesized_value_expression_primary =
    unsigned_value_specification
  | column_reference
  | set_function_specification
  | window_function
  | nested_window_function
  | scalar_subquery
  | case_expression
  | cast_specification
  | field_reference
  | subtype_treatment
  | method_invocation
  | static_method_invocation
  | new_specification
  | attribute_or_method_reference
  | reference_resolution
  | collection_value_constructor
  | array_element_reference
  | multiset_element_reference
  | next_value_expression
  | routine_invocation
    ;

collection_value_constructor =
    array_value_constructor
  | multiset_value_constructor
    ;

# 6.4 value_specification and target_specification

# Function
# Specify one or more values, host parameters, SQL parameters, dynamic
# parameters, or host variables.

# Format
value_specification =
    literal
  | general_value_specification
    ;

unsigned_value_specification =
    unsigned_literal
  | general_value_specification
    ;

general_value_specification =
    host_parameter_specification
  | sql_parameter_reference
  | dynamic_parameter_specification
  | embedded_variable_specification
  | current_collation_specification
  | 'CURRENT_CATALOG'
  | 'CURRENT_DEFAULT_TRANSFORM_GROUP'
  | 'CURRENT_PATH'
  | 'CURRENT_ROLE'
  | 'CURRENT_SCHEMA'
  | 'CURRENT_TRANSFORM_GROUP_FOR_TYPE' path_resolved_user_defined_type_name
  | 'CURRENT_USER'
  | 'SESSION_USER'
  | 'SYSTEM_USER'
  | 'USER'
  | 'VALUE'
    ;

simple_value_specification =
    literal
  | host_parameter_name
  | sql_parameter_reference
  | embedded_variable_name
    ;

target_specification =
    host_parameter_specification
  | sql_parameter_reference
  | column_reference
  | target_array_element_specification
  | dynamic_parameter_specification
  | embedded_variable_specification
    ;

simple_target_specification =
    host_parameter_name
  | sql_parameter_reference
  | column_reference
  | embedded_variable_name
    ;

host_parameter_specification =
    host_parameter_name [indicator_parameter]
    ;

dynamic_parameter_specification =
    question_mark
    ;

embedded_variable_specification =
    embedded_variable_name [indicator_variable]
    ;

indicator_variable =
    ['INDICATOR'] embedded_variable_name
    ;

indicator_parameter =
    ['INDICATOR'] host_parameter_name
    ;

target_array_element_specification =
    target_array_reference
        left_bracket_or_trigraph simple_value_specification right_bracket_or_trigraph
    ;

target_array_reference =
    sql_parameter_reference
  | column_reference
    ;

current_collation_specification =
    'COLLATION' 'FOR' left_paren string_value_expression right_paren
    ;

# 6.5 contextually_typed_value_specification

# Function
# Specify a value whose data type is to be inferred from its context.

# Format
contextually_typed_value_specification =
    implicitly_typed_value_specification
  | default_specification
    ;

implicitly_typed_value_specification =
    null_specification
  | empty_specification
    ;

null_specification =
    'NULL'
    ;

empty_specification =
    'ARRAY' left_bracket_or_trigraph right_bracket_or_trigraph
  | 'MULTISET' left_bracket_or_trigraph right_bracket_or_trigraph
    ;

default_specification =
    'DEFAULT'
    ;

# 6.6 identifier_chain

# Function
# Disambiguate a period-separated chain of identifiers.

# Format
identifier_chain =
    '.'.{identifier}
    ;

basic_identifier_chain =
    identifier_chain
    ;

# 6.7 column_reference

# Function
# Reference a column.

# Format
column_reference =
    basic_identifier_chain
  | 'MODULE' period qualified_identifier period column_name
    ;

# 6.8 sql_parameter_reference

# Function
# Reference an SQL parameter.

# Format
sql_parameter_reference =
    basic_identifier_chain
    ;

# 6.9 set_function_specification

# Function
# Specify a value derived by the application of a function to an argument.

# Format
set_function_specification =
    aggregate_function
  | grouping_operation
    ;

grouping_operation =
    'GROUPING' left_paren ','.{column_reference} right_paren
    ;

# 6.10 window_function

# Function
# Specify a window function.

# Format
window_function =
    window_function_type 'OVER' window_name_or_specification
    ;

window_function_type =
    rank_function_type left_paren right_paren
  | 'ROW_NUMBER' left_paren right_paren
  | aggregate_function
  | ntile_function
  | lead_or_lag_function
  | first_or_last_value_function
  | nth_value_function
    ;

rank_function_type =
    'RANK'
  | 'DENSE_RANK'
  | 'PERCENT_RANK'
  | 'CUME_DIST'
    ;

ntile_function =
    'NTILE' left_paren number_of_tiles right_paren
    ;

number_of_tiles =
    simple_value_specification
  | dynamic_parameter_specification
    ;

lead_or_lag_function =
    lead_or_lag left_paren lead_or_lag_extent
        [comma offset [comma default_expression]] right_paren
        [null_treatment]
    ;

lead_or_lag =
    'LEAD'
  | 'LAG'
    ;

lead_or_lag_extent =
    value_expression
    ;

offset =
    exact_numeric_literal
    ;

default_expression =
    value_expression
    ;

null_treatment =
    'RESPECT' 'NULLS'
  | 'IGNORE' 'NULLS'
    ;

first_or_last_value_function =
    first_or_last_value left_paren value_expression right_paren [null_treatment]
    ;

first_or_last_value =
    'FIRST_VALUE'
  | 'LAST_VALUE'
    ;

nth_value_function =
    'NTH_VALUE' left_paren value_expression comma nth_row right_paren
        [from_first_or_last] [null_treatment]
    ;

nth_row =
    simple_value_specification
  | dynamic_parameter_specification
    ;

from_first_or_last =
    'FROM' 'FIRST'
  | 'FROM' 'LAST'
    ;

window_name_or_specification =
    window_name
  | in_line_window_specification
    ;

in_line_window_specification =
    window_specification
    ;

# 6.11 nested_window_function

# Function
# Specify a function nested in an aggregated argument of an aggregate_function
# simply contained in a window_function.

# Format
nested_window_function =
    nested_row_number_function
  | value_of_expression_at_row
    ;

nested_row_number_function =
    'ROW_NUMBER' left_paren row_marker right_paren
    ;

value_of_expression_at_row =
    'VALUE_OF' left_paren value_expression 'AT' row_marker_expression
        [comma value_of_default_value] right_paren
    ;

row_marker =
    'BEGIN_PARTITION'
  | 'BEGIN_FRAME'
  | 'CURRENT_ROW'
  | 'FRAME_ROW'
  | 'END_FRAME'
  | 'END_PARTITION'
    ;

row_marker_expression =
    row_marker [row_marker_delta]
    ;

row_marker_delta =
    plus_sign row_marker_offset
  | minus_sign row_marker_offset
    ;

row_marker_offset =
    simple_value_specification
  | dynamic_parameter_specification
    ;

value_of_default_value =
    value_expression
    ;

# 6.12 case_expression

# Function
# Specify a conditional value.

# Format
case_expression =
    case_abbreviation
  | case_specification
    ;

case_abbreviation =
    'NULLIF' left_paren value_expression comma value_expression right_paren
  | 'COALESCE' left_paren value_expression {comma value_expression}+ right_paren
    ;

case_specification =
    simple_case
  | searched_case
    ;

simple_case =
    'CASE' case_operand
        {simple_when_clause}+
        [else_clause]
        'END'
    ;

searched_case =
    'CASE'
        {searched_when_clause}+
        [else_clause]
        'END'
    ;

simple_when_clause =
    'WHEN' when_operand_list 'THEN' result
    ;

searched_when_clause =
    'WHEN' search_condition 'THEN' result
    ;

else_clause =
    'ELSE' result
    ;

case_operand =
    row_value_predicand
  | overlaps_predicate_part_1
    ;

when_operand_list =
    ','.{when_operand}
    ;

when_operand =
    row_value_predicand
  | comparison_predicate_part_2
  | between_predicate_part_2
  | in_predicate_part_2
  | character_like_predicate_part_2
  | octet_like_predicate_part_2
  | similar_predicate_part_2
  | regex_like_predicate_part_2
  | null_predicate_part_2
  | quantified_comparison_predicate_part_2
  | normalized_predicate_part_2
  | match_predicate_part_2
  | overlaps_predicate_part_2
  | distinct_predicate_part_2
  | member_predicate_part_2
  | submultiset_predicate_part_2
  | set_predicate_part_2
  | type_predicate_part_2
    ;

result =
    result_expression
  | 'NULL'
    ;

result_expression =
    value_expression
    ;

# 6.13 cast_specification

# Function
# Specify a data conversion.

# Format
cast_specification =
    'CAST' left_paren cast_operand 'AS' cast_target right_paren
    ;

cast_operand =
    value_expression
  | implicitly_typed_value_specification
    ;

cast_target =
    domain_name
  | data_type
    ;

# 6.14 next_value_expression

# Function
# Return the next value of a sequence generator.

# Format
next_value_expression =
    'NEXT' 'VALUE' 'FOR' sequence_generator_name
    ;

# 6.15 field_reference

# Function
# Reference a field of a row value.

# Format
field_reference =
    value_expression_primary period field_name
    ;

# 6.16 subtype_treatment

# Function
# Modify the declared type of an expression.

# Format
subtype_treatment =
    'TREAT' left_paren subtype_operand 'AS' target_subtype right_paren
    ;

subtype_operand =
    value_expression
    ;

target_subtype =
    path_resolved_user_defined_type_name
  | reference_type
    ;

# 6.17 method_invocation

# Function
# Reference an SQL-invoked method of a user-defined type value.

# Format
method_invocation =
    direct_invocation
  | generalized_invocation
    ;

direct_invocation =
    value_expression_primary period method_name [sql_argument_list]
    ;

generalized_invocation =
    left_paren value_expression_primary 'AS' data_type right_paren
        period method_name [sql_argument_list]
    ;

method_selection =
    routine_invocation
    ;

constructor_method_selection =
    routine_invocation
    ;

# 6.18 static_method_invocation

# Function
# Invoke a static method.

# Format
static_method_invocation =
    path_resolved_user_defined_type_name double_colon method_name
        [sql_argument_list]
    ;

static_method_selection =
    routine_invocation
    ;

# 6.19 new_specification

# Function
# Invoke a method on a newly-constructed value of a structured type.

# Format
new_specification =
    'NEW' path_resolved_user_defined_type_name sql_argument_list
    ;

new_invocation =
    method_invocation
  | routine_invocation
    ;

# 6.20 attribute_or_method_reference

# Function
# Return a value acquired by accessing a column of the row identified by a
# value of a reference type or by invoking an SQL-invoked method.

# Format
attribute_or_method_reference =
    value_expression_primary dereference_operator qualified_identifier
        [sql_argument_list]
    ;

dereference_operator =
    right_arrow
    ;

# 6.21 dereference_operation

# Function
# Access a column of the row identified by a value of a reference type.

# Format
dereference_operation =
    reference_value_expression dereference_operator attribute_name
    ;

# 6.22 method_reference

# Function
# Return a value acquired from invoking an SQL-invoked routine that is a
# method.

# Format
method_reference =
    value_expression_primary dereference_operator method_name sql_argument_list
    ;

# 6.23 reference_resolution

# Function
# Obtain the value referenced by a reference value.

# Format
reference_resolution =
    'DEREF' left_paren reference_value_expression right_paren
    ;

# 6.24 array_element_reference

# Function
# Return an element of an array.

# Format
array_element_reference =
    array_value_expression
        left_bracket_or_trigraph
        numeric_value_expression
        right_bracket_or_trigraph
    ;

# 6.25 multiset_element_reference

# Function
# Return the sole element of a multiset of one element.

# Format
multiset_element_reference =
    'ELEMENT' left_paren multiset_value_expression right_paren
    ;

# 6.26 value_expression

# Function
# Specify a value.

# Format
value_expression =
    common_value_expression
  | boolean_value_expression
  | row_value_expression
    ;

common_value_expression =
    numeric_value_expression
  | string_value_expression
  | datetime_value_expression
  | interval_value_expression
  | user_defined_type_value_expression
  | reference_value_expression
  | collection_value_expression
    ;

user_defined_type_value_expression =
    value_expression_primary
    ;

reference_value_expression =
    value_expression_primary
    ;

collection_value_expression =
    array_value_expression
  | multiset_value_expression
    ;

# 6.27 numeric_value_expression

# Function
# Specify a numeric value.

# Format
numeric_value_expression =
    term
  | numeric_value_expression plus_sign term
  | numeric_value_expression minus_sign term
    ;

term =
    factor
  | term asterisk factor
  | term solidus factor
    ;

factor =
    [sign] numeric_primary
    ;

numeric_primary =
    value_expression_primary
  | numeric_value_function
    ;

# 6.28 numeric_value_function

# Function
# Specify a function yielding a value of type numeric.

# Format
numeric_value_function =
    position_expression
  | regex_occurrences_function
  | regex_position_expression
  | extract_expression
  | length_expression
  | cardinality_expression
  | max_cardinality_expression
  | absolute_value_expression
  | modulus_expression
  | natural_logarithm
  | exponential_function
  | power_function
  | square_root
  | floor_function
  | ceiling_function
  | width_bucket_function
    ;

position_expression =
    character_position_expression
  | binary_position_expression
    ;

regex_occurrences_function =
    'OCCURRENCES_REGEX' left_paren
        xquery_pattern ['FLAG' xquery_option_flag]
        'IN' regex_subject_string
        ['FROM' start_position]
        ['USING' char_length_units]
        right_paren
    ;

xquery_pattern =
    character_value_expression
    ;

xquery_option_flag =
    character_value_expression
    ;

regex_subject_string =
    character_value_expression
    ;

regex_position_expression =
    'POSITION_REGEX' left_paren
        [regex_position_start_or_after]
        xquery_pattern ['FLAG' xquery_option_flag]
        'IN' regex_subject_string
        ['FROM' start_position]
        ['USING' char_length_units]
        ['OCCURRENCE' regex_occurrence]
        ['GROUP' regex_capture_group]
        right_paren
    ;

regex_position_start_or_after =
    'START'
  | 'AFTER'
    ;

regex_occurrence =
    numeric_value_expression
    ;

regex_capture_group =
    numeric_value_expression
    ;

character_position_expression =
    'POSITION' left_paren character_value_expression_1 'IN'
        character_value_expression_2
        ['USING' char_length_units] right_paren
    ;

character_value_expression_1 =
    character_value_expression
    ;

character_value_expression_2 =
    character_value_expression
    ;

binary_position_expression =
    'POSITION' left_paren binary_value_expression 'IN'
        binary_value_expression right_paren
    ;

length_expression =
    char_length_expression
  | octet_length_expression
    ;

char_length_expression =
    ('CHAR_LENGTH' | 'CHARACTER_LENGTH') left_paren
        character_value_expression
        ['USING' char_length_units] right_paren
    ;

octet_length_expression =
    'OCTET_LENGTH' left_paren string_value_expression right_paren
    ;

extract_expression =
    'EXTRACT' left_paren extract_field 'FROM' extract_source right_paren
    ;

extract_field =
    primary_datetime_field
  | time_zone_field
    ;

time_zone_field =
    'TIMEZONE_HOUR'
  | 'TIMEZONE_MINUTE'
    ;

extract_source =
    datetime_value_expression
  | interval_value_expression
    ;

cardinality_expression =
    'CARDINALITY' left_paren collection_value_expression right_paren
    ;

max_cardinality_expression =
    'ARRAY_MAX_CARDINALITY' left_paren array_value_expression right_paren
    ;

absolute_value_expression =
    'ABS' left_paren numeric_value_expression right_paren
    ;

modulus_expression =
    'MOD' left_paren numeric_value_expression_dividend comma
        numeric_value_expression_divisor right_paren
    ;

numeric_value_expression_dividend =
    numeric_value_expression
    ;

numeric_value_expression_divisor =
    numeric_value_expression
    ;

natural_logarithm =
    'LN' left_paren numeric_value_expression right_paren
    ;

exponential_function =
    'EXP' left_paren numeric_value_expression right_paren
    ;

power_function =
    'POWER' left_paren numeric_value_expression_base comma
        numeric_value_expression_exponent right_paren
    ;

numeric_value_expression_base =
    numeric_value_expression
    ;

numeric_value_expression_exponent =
    numeric_value_expression
    ;

square_root =
    'SQRT' left_paren numeric_value_expression right_paren
    ;

floor_function =
    'FLOOR' left_paren numeric_value_expression right_paren
    ;

ceiling_function =
    ('CEIL' | 'CEILING') left_paren numeric_value_expression right_paren
    ;

width_bucket_function =
    'WIDTH_BUCKET' left_paren width_bucket_operand
        comma width_bucket_bound_1
        comma width_bucket_bound_2
        comma width_bucket_count right_paren
    ;

width_bucket_operand =
    numeric_value_expression
    ;

width_bucket_bound_1 =
    numeric_value_expression
    ;

width_bucket_bound_2 =
    numeric_value_expression
    ;

width_bucket_count =
    numeric_value_expression
    ;

# 6.29 string_value_expression

# Function
# Specify a character string value or a binary string value.

# Format
string_value_expression =
    character_value_expression
  | binary_value_expression
    ;

character_value_expression =
    concatenation
  | character_factor
    ;

concatenation =
    character_value_expression concatenation_operator character_factor
    ;

character_factor =
    character_primary [collate_clause]
    ;

character_primary =
    value_expression_primary
  | string_value_function
    ;

binary_value_expression =
    binary_concatenation
  | binary_factor
    ;

binary_factor =
    binary_primary
    ;

binary_primary =
    value_expression_primary
  | string_value_function
    ;

binary_concatenation =
    binary_value_expression concatenation_operator binary_factor
    ;

# 6.30 string_value_function

# Function
# Specify a function yielding a value of type character string or binary
# string.

# Format
string_value_function =
    character_value_function
  | binary_value_function
    ;

character_value_function =
    character_substring_function
  | regular_expression_substring_function
  | regex_substring_function
  | fold
  | transcoding
  | character_transliteration
  | regex_transliteration
  | trim_function
  | character_overlay_function
  | normalize_function
  | specific_type_method
    ;

character_substring_function =
    'SUBSTRING' left_paren character_value_expression 'FROM' start_position
        ['FOR' string_length] ['USING' char_length_units] right_paren
    ;

regular_expression_substring_function =
    'SUBSTRING' left_paren character_value_expression 'SIMILAR'
        character_value_expression 'ESCAPE' escape_character right_paren
    ;

regex_substring_function =
    'SUBSTRING_REGEX' left_paren
        xquery_pattern ['FLAG' xquery_option_flag]
        'IN' regex_subject_string
        ['FROM' start_position]
        ['USING' char_length_units]
        ['OCCURRENCE' regex_occurrence]
        ['GROUP' regex_capture_group]
        right_paren
    ;

fold =
    ('UPPER' | 'LOWER') left_paren character_value_expression right_paren
    ;

transcoding =
    'CONVERT' left_paren character_value_expression
        'USING' transcoding_name right_paren
    ;

character_transliteration =
    'TRANSLATE' left_paren character_value_expression
        'USING' transliteration_name right_paren
    ;

regex_transliteration =
    'TRANSLATE_REGEX' left_paren
        xquery_pattern ['FLAG' xquery_option_flag]
        'IN' regex_subject_string
        ['WITH' xquery_replacement_string]
        ['FROM' start_position]
        ['USING' char_length_units]
        ['OCCURRENCE' regex_transliteration_occurrence]
        right_paren
    ;

xquery_replacement_string =
    character_value_expression
    ;

regex_transliteration_occurrence =
    regex_occurrence
  | 'ALL'
    ;

trim_function =
    'TRIM' left_paren trim_operands right_paren
    ;

trim_operands =
    [[trim_specification] [trim_character] 'FROM'] trim_source
    ;

trim_source =
    character_value_expression
    ;

trim_specification =
    'LEADING'
  | 'TRAILING'
  | 'BOTH'
    ;

trim_character =
    character_value_expression
    ;

character_overlay_function =
    'OVERLAY' left_paren character_value_expression
        'PLACING' character_value_expression
        'FROM' start_position ['FOR' string_length]
        ['USING' char_length_units] right_paren
    ;

normalize_function =
    'NORMALIZE' left_paren character_value_expression
        [comma normal_form [comma normalize_function_result_length]] right_paren
    ;

normal_form =
    'NFC'
  | 'NFD'
  | 'NFKC'
  | 'NFKD'
    ;

normalize_function_result_length =
    character_length
  | character_large_object_length
    ;

specific_type_method =
    user_defined_type_value_expression period 'SPECIFICTYPE'
        [left_paren right_paren]
    ;

binary_value_function =
    binary_substring_function
  | binary_trim_function
  | binary_overlay_function
    ;

binary_substring_function =
    'SUBSTRING' left_paren binary_value_expression 'FROM' start_position
        ['FOR' string_length] right_paren
    ;

binary_trim_function =
    'TRIM' left_paren binary_trim_operands right_paren
    ;

binary_trim_operands =
    [[trim_specification] [trim_octet] 'FROM'] binary_trim_source
    ;

binary_trim_source =
    binary_value_expression
    ;

trim_octet =
    binary_value_expression
    ;

binary_overlay_function =
    'OVERLAY' left_paren binary_value_expression
        'PLACING' binary_value_expression
        'FROM' start_position ['FOR' string_length] right_paren
    ;

start_position =
    numeric_value_expression
    ;

string_length =
    numeric_value_expression
    ;

# 6.31 datetime_value_expression

# Function
# Specify a datetime value.

# Format
datetime_value_expression =
    datetime_term
  | interval_value_expression plus_sign datetime_term
  | datetime_value_expression plus_sign interval_term
  | datetime_value_expression minus_sign interval_term
    ;

datetime_term =
    datetime_factor
    ;

datetime_factor =
    datetime_primary [time_zone]
    ;

datetime_primary =
    value_expression_primary
  | datetime_value_function
    ;

time_zone =
    'AT' time_zone_specifier
    ;

time_zone_specifier =
    'LOCAL'
  | 'TIME' 'ZONE' interval_primary
    ;

# 6.32 datetime_value_function

# Function
# Specify a function yielding a value of type datetime.

# Format
datetime_value_function =
    current_date_value_function
  | current_time_value_function
  | current_timestamp_value_function
  | current_local_time_value_function
  | current_local_timestamp_value_function
    ;

current_date_value_function =
    'CURRENT_DATE'
    ;

current_time_value_function =
    'CURRENT_TIME' [left_paren time_precision right_paren]
    ;

current_local_time_value_function =
    'LOCALTIME' [left_paren time_precision right_paren]
    ;

current_timestamp_value_function =
    'CURRENT_TIMESTAMP' [left_paren timestamp_precision right_paren]
    ;

current_local_timestamp_value_function =
    'LOCALTIMESTAMP' [left_paren timestamp_precision right_paren]
    ;

# 6.33 interval_value_expression

# Function
# Specify an interval value.

# Format
interval_value_expression =
    interval_term
  | interval_value_expression_1 plus_sign interval_term_1
  | interval_value_expression_1 minus_sign interval_term_1
  | left_paren datetime_value_expression minus_sign datetime_term right_paren
        interval_qualifier
    ;

interval_term =
    interval_factor
  | interval_term_2 asterisk factor
  | interval_term_2 solidus factor
  | term asterisk interval_factor
    ;

interval_factor =
    [sign] interval_primary
    ;

interval_primary =
    value_expression_primary [interval_qualifier]
  | interval_value_function
    ;

interval_value_expression_1 =
    interval_value_expression
    ;

interval_term_1 =
    interval_term
    ;

interval_term_2 =
    interval_term
    ;

# 6.34 interval_value_function

# Function
# Specify a function yielding a value of type interval.

# Format
interval_value_function =
    interval_absolute_value_function
    ;

interval_absolute_value_function =
    'ABS' left_paren interval_value_expression right_paren
    ;

# 6.35 boolean_value_expression

# Function
# Specify a boolean value.

# Format
boolean_value_expression =
    boolean_term
  | boolean_value_expression 'OR' boolean_term
    ;

boolean_term =
    boolean_factor
  | boolean_term 'AND' boolean_factor
    ;

boolean_factor =
    ['NOT'] boolean_test
    ;

boolean_test =
    boolean_primary ['IS' ['NOT'] truth_value]
    ;

truth_value =
    'TRUE'
  | 'FALSE'
  | 'UNKNOWN'
    ;

boolean_primary =
    predicate
  | boolean_predicand
    ;

boolean_predicand =
    parenthesized_boolean_value_expression
  | nonparenthesized_value_expression_primary
    ;

parenthesized_boolean_value_expression =
    left_paren boolean_value_expression right_paren
    ;

# 6.36 array_value_expression

# Function
# Specify an array value.

# Format
array_value_expression =
    array_concatenation
  | array_primary
    ;

array_concatenation =
    array_value_expression_1 concatenation_operator array_primary
    ;

array_value_expression_1 =
    array_value_expression
    ;

array_primary =
    array_value_function
  | value_expression_primary
    ;

# 6.37 array_value_function

# Function
# Specify a function yielding a value of an array type.

# Format
array_value_function =
    trim_array_function
    ;

trim_array_function =
    'TRIM_ARRAY' left_paren array_value_expression
        comma numeric_value_expression right_paren
    ;

# 6.38 array_value_constructor

# Function
# Specify construction of an array.

# Format
array_value_constructor =
    array_value_constructor_by_enumeration
  | array_value_constructor_by_query
    ;

array_value_constructor_by_enumeration =
    'ARRAY' left_bracket_or_trigraph
        array_element_list right_bracket_or_trigraph
    ;

array_element_list =
    ','.{array_element}
    ;

array_element =
    value_expression
    ;

array_value_constructor_by_query =
    'ARRAY' table_subquery
    ;

# 6.39 multiset_value_expression

# Function
# Specify a multiset value.

# Format
multiset_value_expression =
    multiset_term
  | multiset_value_expression 'MULTISET' 'UNION' ['ALL' | 'DISTINCT'] multiset_term
  | multiset_value_expression 'MULTISET' 'EXCEPT' ['ALL' | 'DISTINCT'] multiset_term
    ;

multiset_term =
    multiset_primary
  | multiset_term 'MULTISET' 'INTERSECT' ['ALL' | 'DISTINCT'] multiset_primary
    ;

multiset_primary =
    multiset_value_function
  | value_expression_primary
    ;

# 6.40 multiset_value_function

# Function
# Specify a function yielding a value of a multiset type.

# Format
multiset_value_function =
    multiset_set_function
    ;

multiset_set_function =
    'SET' left_paren multiset_value_expression right_paren
    ;

# 6.41 multiset_value_constructor

# Function
# Specify construction of a multiset.

# Format
multiset_value_constructor =
    multiset_value_constructor_by_enumeration
  | multiset_value_constructor_by_query
  | table_value_constructor_by_query
    ;

multiset_value_constructor_by_enumeration =
    'MULTISET' left_bracket_or_trigraph multiset_element_list right_bracket_or_trigraph
    ;

multiset_element_list =
    ','.{multiset_element}
    ;

multiset_element =
    value_expression
    ;

multiset_value_constructor_by_query =
    'MULTISET' table_subquery
    ;

table_value_constructor_by_query =
    'TABLE' table_subquery
    ;

# 7 Query expressions

# 7.1 row_value_constructor

# Function
# Specify a value or list of values to be constructed into a row.

# Format
row_value_constructor =
    common_value_expression
  | boolean_value_expression
  | explicit_row_value_constructor
    ;

explicit_row_value_constructor =
    left_paren row_value_constructor_element comma
        row_value_constructor_element_list right_paren
  | 'ROW' left_paren row_value_constructor_element_list right_paren
  | row_subquery
    ;

row_value_constructor_element_list =
    ','.{row_value_constructor_element}
    ;

row_value_constructor_element =
    value_expression
    ;

contextually_typed_row_value_constructor =
    common_value_expression
  | boolean_value_expression
  | contextually_typed_value_specification
  | left_paren contextually_typed_value_specification right_paren
  | left_paren contextually_typed_row_value_constructor_element comma
        contextually_typed_row_value_constructor_element_list right_paren
  | 'ROW' left_paren contextually_typed_row_value_constructor_element_list right_paren
    ;

contextually_typed_row_value_constructor_element_list =
    ','.{contextually_typed_row_value_constructor_element}
    ;

contextually_typed_row_value_constructor_element =
    value_expression
  | contextually_typed_value_specification
    ;

row_value_constructor_predicand =
    common_value_expression
  | boolean_predicand
  | explicit_row_value_constructor
    ;

# 7.2 row_value_expression

# Function
# Specify a row value.

# Format
row_value_expression =
    row_value_special_case
  | explicit_row_value_constructor
    ;

table_row_value_expression =
    row_value_special_case
  | row_value_constructor
    ;

contextually_typed_row_value_expression =
    row_value_special_case
  | contextually_typed_row_value_constructor
    ;

row_value_predicand =
    row_value_special_case
  | row_value_constructor_predicand
    ;

row_value_special_case =
    nonparenthesized_value_expression_primary
    ;

# 7.3 table_value_constructor

# Function
# Specify a set of row_value_expressions to be constructed into a table.

# Format
table_value_constructor =
    'VALUES' row_value_expression_list
    ;

row_value_expression_list =
    ','.{table_row_value_expression}
    ;

contextually_typed_table_value_constructor =
    'VALUES' contextually_typed_row_value_expression_list
    ;

contextually_typed_row_value_expression_list =
    ','.{contextually_typed_row_value_expression}
    ;

# 7.4 table_expression

# Function
# Specify a table or a grouped table.

# Format
table_expression =
    from_clause
        [where_clause]
        [group_by_clause]
        [having_clause]
        [window_clause]
    ;

# 7.5 from_clause

# Function
# Specify a table derived from one or more tables.

# Format
from_clause =
    'FROM' table_reference_list
    ;

table_reference_list =
    ','.{table_reference}
    ;

# 7.6 table_reference

# Function
# Reference a table.

# Format
table_reference =
    table_factor
  | joined_table
    ;

table_factor =
    table_primary [sample_clause]
    ;

sample_clause =
    'TABLESAMPLE' sample_method left_paren sample_percentage right_paren
        [repeatable_clause]
    ;

sample_method =
    'BERNOULLI'
  | 'SYSTEM'
    ;

repeatable_clause =
    'REPEATABLE' left_paren repeat_argument right_paren
    ;

sample_percentage =
    numeric_value_expression
    ;

repeat_argument =
    numeric_value_expression
    ;

table_primary =
    table_or_query_name [query_system_time_period_specification]
        [['AS'] correlation_name
        [left_paren derived_column_list right_paren]]
  | derived_table ['AS'] correlation_name
        [left_paren derived_column_list right_paren]
  | lateral_derived_table ['AS'] correlation_name
        [left_paren derived_column_list right_paren]
  | collection_derived_table ['AS'] correlation_name
        [left_paren derived_column_list right_paren]
  | table_function_derived_table ['AS'] correlation_name
        [left_paren derived_column_list right_paren]
  | only_spec [['AS'] correlation_name
        [left_paren derived_column_list right_paren]]
  | data_change_delta_table [['AS'] correlation_name
        [left_paren derived_column_list right_paren]]
  | parenthesized_joined_table
    ;

query_system_time_period_specification =
    'FOR' 'SYSTEM_TIME' 'AS' 'OF' point_in_time_1
  | 'FOR' 'SYSTEM_TIME' 'BETWEEN' ['ASYMMETRIC' | 'SYMMETRIC']
        point_in_time_1 'AND' point_in_time_2
  | 'FOR' 'SYSTEM_TIME' 'FROM' point_in_time_1 'TO' point_in_time_2
    ;

point_in_time_1 =
    point_in_time
    ;

point_in_time_2 =
    point_in_time
    ;

point_in_time =
    datetime_value_expression
    ;

only_spec =
    'ONLY' left_paren table_or_query_name right_paren
    ;

lateral_derived_table =
    'LATERAL' table_subquery
    ;

collection_derived_table =
    'UNNEST' left_paren ','.{collection_value_expression} right_paren
        ['WITH' 'ORDINALITY']
    ;

table_function_derived_table =
    'TABLE' left_paren collection_value_expression right_paren
    ;

derived_table =
    table_subquery
    ;

table_or_query_name =
    table_name
  | transition_table_name
  | query_name
    ;

derived_column_list =
    column_name_list
    ;

column_name_list =
    ','.{column_name}
    ;

data_change_delta_table =
    result_option 'TABLE' left_paren data_change_statement right_paren
    ;

data_change_statement =
    delete_statement_searched
  | insert_statement
  | merge_statement
  | update_statement_searched
    ;

result_option =
    'FINAL'
  | 'NEW'
  | 'OLD'
    ;

parenthesized_joined_table =
    left_paren parenthesized_joined_table right_paren
  | left_paren joined_table right_paren
    ;

# 7.7 joined_table

# Function
# Specify a table derived from a Cartesian product, inner join, or outer join.

# Format
joined_table =
    cross_join
  | qualified_join
  | natural_join
    ;

cross_join =
    table_reference 'CROSS' 'JOIN' table_factor
    ;

qualified_join =
    (table_reference | partitioned_join_table)
        [join_type] 'JOIN'
        (table_reference | partitioned_join_table)
        join_specification
    ;

partitioned_join_table =
    table_factor 'PARTITION' 'BY'
        partitioned_join_column_reference_list
    ;

partitioned_join_column_reference_list =
    left_paren ','.{partitioned_join_column_reference}
        right_paren
    ;

partitioned_join_column_reference =
    column_reference
    ;

natural_join =
    (table_reference | partitioned_join_table)
        'NATURAL' [join_type] 'JOIN'
        (table_factor | partitioned_join_table)
    ;

join_specification =
    join_condition
  | named_columns_join
    ;

join_condition =
    'ON' search_condition
    ;

named_columns_join =
    'USING' left_paren join_column_list right_paren
    ;

join_type =
    'INNER'
  | outer_join_type ['OUTER']
    ;

outer_join_type =
    'LEFT'
  | 'RIGHT'
  | 'FULL'
    ;

join_column_list =
    column_name_list
    ;

# 7.8 where_clause

# Function
# Specify a table derived by the application of a search_condition to the
# result of the preceding from_clause.

# Format
where_clause =
    'WHERE' search_condition
    ;

# 7.9 group_by_clause

# Function
# Specify a grouped table derived by the application of the group_by_clause to
# the result of the previously specified clause.

# Format
group_by_clause =
    'GROUP' 'BY' [set_quantifier] grouping_element_list
    ;

grouping_element_list =
    ','.{grouping_element}
    ;

grouping_element =
    ordinary_grouping_set
  | rollup_list
  | cube_list
  | grouping_sets_specification
  | empty_grouping_set
    ;

ordinary_grouping_set =
    grouping_column_reference
  | left_paren grouping_column_reference_list right_paren
    ;

grouping_column_reference =
    column_reference [collate_clause]
    ;

grouping_column_reference_list =
    ','.{grouping_column_reference}
    ;

rollup_list =
    'ROLLUP' left_paren ordinary_grouping_set_list right_paren
    ;

ordinary_grouping_set_list =
    ','.{ordinary_grouping_set}
    ;

cube_list =
    'CUBE' left_paren ordinary_grouping_set_list right_paren
    ;

grouping_sets_specification =
    'GROUPING' 'SETS' left_paren grouping_set_list right_paren
    ;

grouping_set_list =
    ','.{grouping_set}
    ;

grouping_set =
    ordinary_grouping_set
  | rollup_list
  | cube_list
  | grouping_sets_specification
  | empty_grouping_set
    ;

empty_grouping_set =
    left_paren right_paren
    ;

# 7.10 having_clause

# Function
# Specify a grouped table derived by the elimination of groups that do not
# satisfy a search_condition.

# Format
having_clause =
    'HAVING' search_condition
    ;

# 7.11 window_clause

# Function
# Specify one or more window definitions.

# Format
window_clause =
    'WINDOW' window_definition_list
    ;

window_definition_list =
    ','.{window_definition}
    ;

window_definition =
    new_window_name 'AS' window_specification
    ;

new_window_name =
    window_name
    ;

window_specification =
    left_paren window_specification_details right_paren
    ;

window_specification_details =
    [existing_window_name]
        [window_partition_clause]
        [window_order_clause]
        [window_frame_clause]
    ;

existing_window_name =
    window_name
    ;

window_partition_clause =
    'PARTITION' 'BY' window_partition_column_reference_list
    ;

window_partition_column_reference_list =
    ','.{window_partition_column_reference}
    ;

window_partition_column_reference =
    column_reference [collate_clause]
    ;

window_order_clause =
    'ORDER' 'BY' sort_specification_list
    ;

window_frame_clause =
    window_frame_units window_frame_extent
        [window_frame_exclusion]
    ;

window_frame_units =
    'ROWS'
  | 'RANGE'
  | 'GROUPS'
    ;

window_frame_extent =
    window_frame_start
  | window_frame_between
    ;

window_frame_start =
    'UNBOUNDED' 'PRECEDING'
  | window_frame_preceding
  | 'CURRENT' 'ROW'
    ;

window_frame_preceding =
    unsigned_value_specification 'PRECEDING'
    ;

window_frame_between =
    'BETWEEN' window_frame_bound_1 'AND' window_frame_bound_2
    ;

window_frame_bound_1 =
    window_frame_bound
    ;

window_frame_bound_2 =
    window_frame_bound
    ;

window_frame_bound =
    window_frame_start
  | 'UNBOUNDED' 'FOLLOWING'
  | window_frame_following
    ;

window_frame_following =
    unsigned_value_specification 'FOLLOWING'
    ;

window_frame_exclusion =
    'EXCLUDE' 'CURRENT' 'ROW'
  | 'EXCLUDE' 'GROUP'
  | 'EXCLUDE' 'TIES'
  | 'EXCLUDE' 'NO' 'OTHERS'
    ;

# 7.12 query_specification

# Function
# Specify a table derived from the result of a table_expression.

# Format
query_specification =
    'SELECT' [set_quantifier] select_list table_expression
    ;

select_list =
    asterisk
  | ','.{select_sublist}
    ;

select_sublist =
    derived_column
  | qualified_asterisk
    ;

qualified_asterisk =
    asterisked_identifier_chain period asterisk
  | all_fields_reference
    ;

asterisked_identifier_chain =
    '.'.{asterisked_identifier}
    ;

asterisked_identifier =
    identifier
    ;

derived_column =
    value_expression [as_clause]
    ;

as_clause =
    ['AS'] column_name
    ;

all_fields_reference =
    value_expression_primary period asterisk
        ['AS' left_paren all_fields_column_name_list right_paren]
    ;

all_fields_column_name_list =
    column_name_list
    ;

# 7.13 query_expression

# Function
# Specify a table.

# Format
query_expression =
    [with_clause] query_expression_body
        [order_by_clause] [result_offset_clause] [fetch_first_clause]
    ;

with_clause =
    'WITH' ['RECURSIVE'] with_list
    ;

with_list =
    ','.{with_list_element}
    ;

with_list_element =
    query_name [left_paren with_column_list right_paren]
        'AS' table_subquery [search_or_cycle_clause]
    ;

with_column_list =
    column_name_list
    ;

query_expression_body =
    query_term
  | query_expression_body 'UNION' ['ALL' | 'DISTINCT']
        [corresponding_spec] query_term
  | query_expression_body 'EXCEPT' ['ALL' | 'DISTINCT']
        [corresponding_spec] query_term
    ;

query_term =
    query_primary
  | query_term 'INTERSECT' ['ALL' | 'DISTINCT']
        [corresponding_spec] query_primary
    ;

query_primary =
    simple_table
  | left_paren query_expression_body
        [order_by_clause] [result_offset_clause] [fetch_first_clause]
        right_paren
    ;

simple_table =
    query_specification
  | table_value_constructor
  | explicit_table
    ;

explicit_table =
    'TABLE' table_or_query_name
    ;

corresponding_spec =
    'CORRESPONDING' ['BY' left_paren corresponding_column_list right_paren]
    ;

corresponding_column_list =
    column_name_list
    ;

order_by_clause =
    'ORDER' 'BY' sort_specification_list
    ;

result_offset_clause =
    'OFFSET' offset_row_count ('ROW' | 'ROWS')
    ;

fetch_first_clause =
    'FETCH' ('FIRST' | 'NEXT') [fetch_first_quantity] ('ROW' | 'ROWS') ('ONLY' | 'WITH' 'TIES')
    ;

fetch_first_quantity =
    fetch_first_row_count
  | fetch_first_percentage
    ;

offset_row_count =
    simple_value_specification
    ;

fetch_first_row_count =
    simple_value_specification
    ;

fetch_first_percentage =
    simple_value_specification 'PERCENT'
    ;

# 7.14 search_or_cycle_clause

# Function
# Specify the generation of ordering and cycle detection information in the
# result of recursive query expressions.

# Format
search_or_cycle_clause =
    search_clause
  | cycle_clause
  | search_clause cycle_clause
    ;

search_clause =
    'SEARCH' recursive_search_order 'SET' sequence_column
    ;

recursive_search_order =
    'DEPTH' 'FIRST' 'BY' column_name_list
  | 'BREADTH' 'FIRST' 'BY' column_name_list
    ;

sequence_column =
    column_name
    ;

cycle_clause =
    'CYCLE' cycle_column_list 'SET' cycle_mark_column 'TO' cycle_mark_value
        'DEFAULT' non_cycle_mark_value 'USING' path_column
    ;

cycle_column_list =
    ','.{cycle_column}
    ;

cycle_column =
    column_name
    ;

cycle_mark_column =
    column_name
    ;

path_column =
    column_name
    ;

cycle_mark_value =
    value_expression
    ;

non_cycle_mark_value =
    value_expression
    ;

# 7.15 subquery

# Function
# Specify a scalar value, a row, or a table derived from a query_expression.

# Format
scalar_subquery =
    subquery
    ;

row_subquery =
    subquery
    ;

table_subquery =
    subquery
    ;

subquery =
    left_paren query_expression right_paren
    ;

# 8 Predicates

# 8.1 predicate

# Function
# Specify a condition that can be evaluated to give a boolean value.

# Format
predicate =
    comparison_predicate
  | between_predicate
  | in_predicate
  | like_predicate
  | similar_predicate
  | regex_like_predicate
  | null_predicate
  | quantified_comparison_predicate
  | exists_predicate
  | unique_predicate
  | normalized_predicate
  | match_predicate
  | overlaps_predicate
  | distinct_predicate
  | member_predicate
  | submultiset_predicate
  | set_predicate
  | type_predicate
  | period_predicate
    ;

# 8.2 comparison_predicate

# Function
# Specify a comparison of two row values.

# Format
comparison_predicate =
    row_value_predicand comparison_predicate_part_2
    ;

comparison_predicate_part_2 =
    comp_op row_value_predicand
    ;

comp_op =
    equals_operator
  | not_equals_operator
  | less_than_operator
  | greater_than_operator
  | less_than_or_equals_operator
  | greater_than_or_equals_operator
    ;

# 8.3 between_predicate

# Function
# Specify a range comparison.

# Format
between_predicate =
    row_value_predicand between_predicate_part_2
    ;

between_predicate_part_2 =
    ['NOT'] 'BETWEEN' ['ASYMMETRIC' | 'SYMMETRIC']
        row_value_predicand 'AND' row_value_predicand
    ;

# 8.4 in_predicate

# Function
# Specify a quantified comparison.

# Format
in_predicate =
    row_value_predicand in_predicate_part_2
    ;

in_predicate_part_2 =
    ['NOT'] 'IN' in_predicate_value
    ;

in_predicate_value =
    table_subquery
  | left_paren in_value_list right_paren
    ;

in_value_list =
    ','.{row_value_expression}
    ;

# 8.5 like_predicate

# Function
# Specify a pattern-match comparison.

# Format
like_predicate =
    character_like_predicate
  | octet_like_predicate
    ;

character_like_predicate =
    row_value_predicand character_like_predicate_part_2
    ;

character_like_predicate_part_2 =
    ['NOT'] 'LIKE' character_pattern ['ESCAPE' escape_character]
    ;

character_pattern =
    character_value_expression
    ;

escape_character =
    character_value_expression
    ;

octet_like_predicate =
    row_value_predicand octet_like_predicate_part_2
    ;

octet_like_predicate_part_2 =
    ['NOT'] 'LIKE' octet_pattern ['ESCAPE' escape_octet]
    ;

octet_pattern =
    binary_value_expression
    ;

escape_octet =
    binary_value_expression
    ;

# 8.6 similar_predicate

# Function
# Specify a character string similarity by means of a regular expression.

# Format
similar_predicate =
    row_value_predicand similar_predicate_part_2
    ;

similar_predicate_part_2 =
    ['NOT'] 'SIMILAR' 'TO' similar_pattern ['ESCAPE' escape_character]
    ;

similar_pattern =
    character_value_expression
    ;

regular_expression =
    regular_term
  | regular_expression vertical_bar regular_term
    ;

regular_term =
    regular_factor
  | regular_term regular_factor
    ;

regular_factor =
    regular_primary
  | regular_primary asterisk
  | regular_primary plus_sign
  | regular_primary question_mark
  | regular_primary repeat_factor
    ;

repeat_factor =
    left_brace low_value [upper_limit] right_brace
    ;

upper_limit =
    comma [high_value]
    ;

low_value =
    unsigned_integer
    ;

high_value =
    unsigned_integer
    ;

regular_primary =
    character_specifier
  | percent
  | regular_character_set
  | left_paren regular_expression right_paren
    ;

character_specifier =
    non_escaped_character
  | escaped_character
    ;

# SEE_SYNTAX_RULES
non_escaped_character =
    /[^\[\]\(\)\|\^\-\+\*%_\?\{\n]/
    ;

# SEE_SYNTAX_RULES
escaped_character =
    escape_char special_character
  | escape_char escape_char
    ;

escape_char =
    /\\/
    ;

special_character =
    /\[\]\(\)\|\^\-\+\*%_\?\{/
    ;

regular_character_set =
    underscore
  | left_bracket {character_enumeration}+ right_bracket
  | left_bracket circumflex {character_enumeration}+ right_bracket
  | left_bracket {character_enumeration_include}+
        circumflex {character_enumeration_exclude}+ right_bracket
    ;

character_enumeration_include =
    character_enumeration
    ;

character_enumeration_exclude =
    character_enumeration
    ;

character_enumeration =
    character_specifier
  | character_specifier minus_sign character_specifier
  | left_bracket colon regular_character_set_identifier colon right_bracket
    ;

regular_character_set_identifier =
    identifier
    ;

# 8.7 regex_like_predicate

# Function
# Specify a pattern-match comparison using an XQuery regular expression.

# Format
regex_like_predicate =
    row_value_predicand regex_like_predicate_part_2
    ;

regex_like_predicate_part_2 =
    ['NOT'] 'LIKE_REGEX' xquery_pattern ['FLAG' xquery_option_flag]
    ;

# 8.8 null_predicate

# Function
# Specify a test for a null value.

# Format
null_predicate =
    row_value_predicand null_predicate_part_2
    ;

null_predicate_part_2 =
    'IS' ['NOT'] 'NULL'
    ;

# 8.9 quantified_comparison_predicate

# Function
# Specify a quantified comparison.

# Format
quantified_comparison_predicate =
    row_value_predicand quantified_comparison_predicate_part_2
    ;

quantified_comparison_predicate_part_2 =
    comp_op quantifier table_subquery
    ;

quantifier =
    all
  | some
    ;

all =
    'ALL'
    ;

some =
    'SOME'
  | 'ANY'
    ;

# 8.10 exists_predicate

# Function
# Specify a test for a non-empty set.

# Format
exists_predicate =
    'EXISTS' table_subquery
    ;

# 8.11 unique_predicate

# Function
# Specify a test for the absence of duplicate rows.

# Format
unique_predicate =
    'UNIQUE' table_subquery
    ;

# 8.12 normalized_predicate

# Function
# Determine whether a character string value is normalized.

# Format
normalized_predicate =
    row_value_predicand normalized_predicate_part_2
    ;

normalized_predicate_part_2 =
    'IS' ['NOT'] [normal_form] 'NORMALIZED'
    ;

# 8.13 match_predicate

# Function
# Specify a test for matching rows.

# Format
match_predicate =
    row_value_predicand match_predicate_part_2
    ;

match_predicate_part_2 =
    'MATCH' ['UNIQUE'] ['SIMPLE' | 'PARTIAL' | 'FULL'] table_subquery
    ;

# 8.14 overlaps_predicate

# Function
# Specify a test for an overlap between two datetime periods.

# Format
overlaps_predicate =
    overlaps_predicate_part_1 overlaps_predicate_part_2
    ;

overlaps_predicate_part_1 =
    row_value_predicand_1
    ;

overlaps_predicate_part_2 =
    'OVERLAPS' row_value_predicand_2
    ;

row_value_predicand_1 =
    row_value_predicand
    ;

row_value_predicand_2 =
    row_value_predicand
    ;

# 8.15 distinct_predicate

# Function
# Specify a test of whether two row values are distinct

# Format
distinct_predicate =
    row_value_predicand_3 distinct_predicate_part_2
    ;

distinct_predicate_part_2 =
    'IS' ['NOT'] 'DISTINCT' 'FROM' row_value_predicand_4
    ;

row_value_predicand_3 =
    row_value_predicand
    ;

row_value_predicand_4 =
    row_value_predicand
    ;

# 8.16 member_predicate

# Function
# Specify a test of whether a value is a member of a multiset.

# Format
member_predicate =
    row_value_predicand member_predicate_part_2
    ;

member_predicate_part_2 =
    ['NOT'] 'MEMBER' ['OF'] multiset_value_expression
    ;

# 8.17 submultiset_predicate

# Function
# Specify a test of whether a multiset is a submultiset of another multiset.

# Format
submultiset_predicate =
    row_value_predicand submultiset_predicate_part_2
    ;

submultiset_predicate_part_2 =
    ['NOT'] 'SUBMULTISET' ['OF'] multiset_value_expression
    ;

# 8.18 set_predicate

# Function
# Specify a test of whether a multiset is a set (that is, does not contain any
# duplicates).

# Format
set_predicate =
    row_value_predicand set_predicate_part_2
    ;

set_predicate_part_2 =
    'IS' ['NOT'] 'A' 'SET'
    ;

# 8.19 type_predicate

# Function
# Specify a type test.

# Format
type_predicate =
    row_value_predicand type_predicate_part_2
    ;

type_predicate_part_2 =
    'IS' ['NOT'] 'OF' left_paren type_list right_paren
    ;

type_list =
    ','.{user_defined_type_specification}
    ;

user_defined_type_specification =
    inclusive_user_defined_type_specification
  | exclusive_user_defined_type_specification
    ;

inclusive_user_defined_type_specification =
    path_resolved_user_defined_type_name
    ;

exclusive_user_defined_type_specification =
    'ONLY' path_resolved_user_defined_type_name
    ;

# 8.20 period_predicate

# Function
# Specify a test to determine the relationship between periods.

# Format
period_predicate =
    period_overlaps_predicate
  | period_equals_predicate
  | period_contains_predicate
  | period_precedes_predicate
  | period_succeeds_predicate
  | period_immediately_precedes_predicate
  | period_immediately_succeeds_predicate
    ;

period_overlaps_predicate =
    period_predicand_1 period_overlaps_predicate_part_2
    ;

period_overlaps_predicate_part_2 =
    'OVERLAPS' period_predicand_2
    ;

period_predicand_1 =
    period_predicand
    ;

period_predicand_2 =
    period_predicand
    ;

period_predicand =
    period_reference
  | 'PERIOD' left_paren period_start_value comma period_end_value right_paren
    ;

period_reference =
    basic_identifier_chain
    ;

period_start_value =
    datetime_value_expression
    ;

period_end_value =
    datetime_value_expression
    ;

period_equals_predicate =
    period_predicand_1 period_equals_predicate_part_2
    ;

period_equals_predicate_part_2 =
    'EQUALS' period_predicand_2
    ;

period_contains_predicate =
    period_predicand_1 period_contains_predicate_part_2
    ;

period_contains_predicate_part_2 =
    'CONTAINS' period_or_point_in_time_predicand
    ;

period_or_point_in_time_predicand =
    period_predicand
  | datetime_value_expression
    ;

period_precedes_predicate =
    period_predicand_1 period_precedes_predicate_part_2
    ;

period_precedes_predicate_part_2 =
    'PRECEDES' period_predicand_2
    ;

period_succeeds_predicate =
    period_predicand_1 period_succeeds_predicate_part_2
    ;

period_succeeds_predicate_part_2 =
    'SUCCEEDS' period_predicand_2
    ;

period_immediately_precedes_predicate =
    period_predicand_1 period_immediately_precedes_predicate_part_2
    ;

period_immediately_precedes_predicate_part_2 =
    'IMMEDIATELY' 'PRECEDES' period_predicand_2
    ;

period_immediately_succeeds_predicate =
    period_predicand_1 period_immediately_succeeds_predicate_part_2
    ;

period_immediately_succeeds_predicate_part_2 =
    'IMMEDIATELY' 'SUCCEEDS' period_predicand_2
    ;

# 8.21 search_condition

# Function
# Specify a condition that is True, False, or Unknown, depending on the value
# of a boolean_value_expression.

# Format
search_condition =
    boolean_value_expression
    ;

# 10 Additional common elements

# 10.1 interval_qualifier

# Function
# Specify the precision of an interval data type.

# Format
interval_qualifier =
    start_field 'TO' end_field
  | single_datetime_field
    ;

start_field =
    non_second_primary_datetime_field
        [left_paren interval_leading_field_precision right_paren]
    ;

end_field =
    non_second_primary_datetime_field
  | 'SECOND' [left_paren interval_fractional_seconds_precision right_paren]
    ;

single_datetime_field =
    non_second_primary_datetime_field
        [left_paren interval_leading_field_precision right_paren]
  | 'SECOND' [left_paren interval_leading_field_precision
        [comma interval_fractional_seconds_precision] right_paren]
    ;

primary_datetime_field =
    non_second_primary_datetime_field
  | 'SECOND'
    ;

non_second_primary_datetime_field =
    'YEAR'
  | 'MONTH'
  | 'DAY'
  | 'HOUR'
  | 'MINUTE'
    ;

interval_fractional_seconds_precision =
    unsigned_integer
    ;

interval_leading_field_precision =
    unsigned_integer
    ;

# 10.2 language_clause

# Function
# Specify a programming language.

# Format
language_clause =
    'LANGUAGE' language_name
    ;

language_name =
    'ADA'
  | 'C'
  | 'COBOL'
  | 'FORTRAN'
  | 'M'
  | 'MUMPS'
  | 'PASCAL'
  | 'PLI'
  | 'SQL'
    ;

# 10.3 path_specification

# Function
# Specify an order for searching for an SQL-invoked routine.

# Format
path_specification =
    'PATH' schema_name_list
    ;

schema_name_list =
    ','.{schema_name}
    ;

# 10.4 routine_invocation

# Function
# Invoke an SQL-invoked routine.

# Format
routine_invocation =
    routine_name sql_argument_list
    ;

routine_name =
    [schema_name period] qualified_identifier
    ;

sql_argument_list =
    left_paren [','.{sql_argument}] right_paren
    ;

sql_argument =
    value_expression
  | generalized_expression
  | target_specification
  | contextually_typed_value_specification
  | named_argument_specification
    ;

generalized_expression =
    value_expression 'AS' path_resolved_user_defined_type_name
    ;

named_argument_specification =
    sql_parameter_name named_argument_assignment_token
        named_argument_sql_argument
    ;

named_argument_sql_argument =
    value_expression
  | target_specification
  | contextually_typed_value_specification
    ;

# 10.5 character_set_specification

# Function
# Identify a character set.

# Format
character_set_specification =
    standard_character_set_name
  | implementation_defined_character_set_name
  | user_defined_character_set_name
    ;

standard_character_set_name =
    character_set_name
    ;

implementation_defined_character_set_name =
    character_set_name
    ;

user_defined_character_set_name =
    character_set_name
    ;

# 10.6 specific_routine_designator

# Function
# Specify an SQL-invoked routine.

# Format
specific_routine_designator =
    'SPECIFIC' routine_type specific_name
  | routine_type member_name ['FOR' schema_resolved_user_defined_type_name]
    ;

routine_type =
    'ROUTINE'
  | 'FUNCTION'
  | 'PROCEDURE'
  | ['INSTANCE' | 'STATIC' | 'CONSTRUCTOR'] 'METHOD'
    ;

member_name =
    member_name_alternatives [data_type_list]
    ;

member_name_alternatives =
    schema_qualified_routine_name
  | method_name
    ;

data_type_list =
    left_paren [','.{data_type}] right_paren
    ;

# 10.7 collate_clause

# Function
# Specify a default collation.

# Format
collate_clause =
    'COLLATE' collation_name
    ;

# 10.8 constraint_name_definition and constraint_characteristics

# Function
# Specify the name of a constraint and its characteristics.

# Format
constraint_name_definition =
    'CONSTRAINT' constraint_name
    ;

constraint_characteristics =
    constraint_check_time [['NOT'] 'DEFERRABLE'] [constraint_enforcement]
  | ['NOT'] 'DEFERRABLE' [constraint_check_time] [constraint_enforcement]
  | constraint_enforcement
    ;

constraint_check_time =
    'INITIALLY' 'DEFERRED'
  | 'INITIALLY' 'IMMEDIATE'
    ;

constraint_enforcement =
    ['NOT'] 'ENFORCED'
    ;

# 10.9 aggregate_function

# Function
# Specify a value computed from a collection of rows.

# Format
aggregate_function =
    'COUNT' left_paren asterisk right_paren [filter_clause]
  | general_set_function [filter_clause]
  | binary_set_function [filter_clause]
  | ordered_set_function [filter_clause]
  | array_aggregate_function [filter_clause]
    ;

general_set_function =
    set_function_type left_paren [set_quantifier]
        value_expression right_paren
    ;

set_function_type =
    computational_operation
    ;

computational_operation =
    'AVG'
  | 'MAX'
  | 'MIN'
  | 'SUM'
  | 'EVERY'
  | 'ANY'
  | 'SOME'
  | 'COUNT'
  | 'STDDEV_POP'
  | 'STDDEV_SAMP'
  | 'VAR_SAMP'
  | 'VAR_POP'
  | 'COLLECT'
  | 'FUSION'
  | 'INTERSECTION'
    ;

set_quantifier =
    'DISTINCT'
  | 'ALL'
    ;

filter_clause =
    'FILTER' left_paren 'WHERE' search_condition right_paren
    ;

binary_set_function =
    binary_set_function_type left_paren dependent_variable_expression comma
        independent_variable_expression right_paren
    ;

binary_set_function_type =
    'COVAR_POP'
  | 'COVAR_SAMP'
  | 'CORR'
  | 'REGR_SLOPE'
  | 'REGR_INTERCEPT'
  | 'REGR_COUNT'
  | 'REGR_R2'
  | 'REGR_AVGX'
  | 'REGR_AVGY'
  | 'REGR_SXX'
  | 'REGR_SYY'
  | 'REGR_SXY'
    ;

dependent_variable_expression =
    numeric_value_expression
    ;

independent_variable_expression =
    numeric_value_expression
    ;

ordered_set_function =
    hypothetical_set_function
  | inverse_distribution_function
    ;

hypothetical_set_function =
    rank_function_type left_paren
        hypothetical_set_function_value_expression_list right_paren
        within_group_specification
    ;

within_group_specification =
    'WITHIN' 'GROUP' left_paren 'ORDER' 'BY' sort_specification_list right_paren
    ;

hypothetical_set_function_value_expression_list =
    ','.{value_expression}
    ;

inverse_distribution_function =
    inverse_distribution_function_type left_paren
        inverse_distribution_function_argument right_paren
        within_group_specification
    ;

inverse_distribution_function_argument =
    numeric_value_expression
    ;

inverse_distribution_function_type =
    'PERCENTILE_CONT'
  | 'PERCENTILE_DISC'
    ;

array_aggregate_function =
    'ARRAY_AGG'
        left_paren value_expression ['ORDER' 'BY' sort_specification_list] right_paren
    ;

# 10.10 sort_specification_list

# Function
# Specify a sort order.

# Format
sort_specification_list =
    ','.{sort_specification}
    ;

sort_specification =
    sort_key [ordering_specification] [null_ordering]
    ;

sort_key =
    value_expression
    ;

ordering_specification =
    'ASC'
  | 'DESC'
    ;

null_ordering =
    'NULLS' 'FIRST'
  | 'NULLS' 'LAST'
    ;

# 11 Schema definition and manipulation

# 11.1 schema_definition

# Function
# Define a schema.

# Format
schema_definition =
    'CREATE' 'SCHEMA' schema_name_clause
        [schema_character_set_or_path]
        [{schema_element}+]
    ;

schema_character_set_or_path =
    schema_character_set_specification
  | schema_path_specification
  | schema_character_set_specification schema_path_specification
  | schema_path_specification schema_character_set_specification
    ;

schema_name_clause =
    schema_name
  | 'AUTHORIZATION' schema_authorization_identifier
  | schema_name 'AUTHORIZATION' schema_authorization_identifier
    ;

schema_authorization_identifier =
    authorization_identifier
    ;

schema_character_set_specification =
    'DEFAULT' 'CHARACTER' 'SET' character_set_specification
    ;

schema_path_specification =
    path_specification
    ;

schema_element =
    table_definition
  | view_definition
  | domain_definition
  | character_set_definition
  | collation_definition
  | transliteration_definition
  | assertion_definition
  | trigger_definition
  | user_defined_type_definition
  | user_defined_cast_definition
  | user_defined_ordering_definition
  | transform_definition
  | schema_routine
  | sequence_generator_definition
  | grant_statement
  | role_definition
    ;

# 11.2 drop_schema_statement

# Function
# Destroy a schema.

# Format
drop_schema_statement =
    'DROP' 'SCHEMA' schema_name drop_behavior
    ;

drop_behavior =
    'CASCADE'
  | 'RESTRICT'
    ;

# 11.3 table_definition

# Function
# Define a persistent base table, a created local temporary table, or a global
# temporary table.

# Format
table_definition =
    'CREATE' [table_scope] 'TABLE' table_name table_contents_source
        ['WITH' system_versioning_clause]
        ['ON' 'COMMIT' table_commit_action 'ROWS']
    ;

table_contents_source =
    table_element_list
  | typed_table_clause
  | as_subquery_clause
    ;

table_scope =
    global_or_local 'TEMPORARY'
    ;

global_or_local =
    'GLOBAL'
  | 'LOCAL'
    ;

system_versioning_clause =
    'SYSTEM' 'VERSIONING'
    ;

table_commit_action =
    'PRESERVE'
  | 'DELETE'
    ;

table_element_list =
    left_paren ','.{table_element} right_paren
    ;

table_element =
    column_definition
  | table_period_definition
  | table_constraint_definition
  | like_clause
    ;

typed_table_clause =
    'OF' path_resolved_user_defined_type_name [subtable_clause]
        [typed_table_element_list]
    ;

typed_table_element_list =
    left_paren ','.{typed_table_element} right_paren
    ;

typed_table_element =
    column_options
  | table_constraint_definition
  | self_referencing_column_specification
    ;

self_referencing_column_specification =
    'REF' 'IS' self_referencing_column_name [reference_generation]
    ;

reference_generation =
    'SYSTEM' 'GENERATED'
  | 'USER' 'GENERATED'
  | 'DERIVED'
    ;

self_referencing_column_name =
    column_name
    ;

column_options =
    column_name 'WITH' 'OPTIONS' column_option_list
    ;

column_option_list =
    [scope_clause] [default_clause] [{column_constraint_definition}+]
    ;

subtable_clause =
    'UNDER' supertable_clause
    ;

supertable_clause =
    supertable_name
    ;

supertable_name =
    table_name
    ;

like_clause =
    'LIKE' table_name [like_options]
    ;

like_options =
    {like_option}+
    ;

like_option =
    identity_option
  | column_default_option
  | generation_option
    ;

identity_option =
    'INCLUDING' 'IDENTITY'
  | 'EXCLUDING' 'IDENTITY'
    ;

column_default_option =
    'INCLUDING' 'DEFAULTS'
  | 'EXCLUDING' 'DEFAULTS'
    ;

generation_option =
    'INCLUDING' 'GENERATED'
  | 'EXCLUDING' 'GENERATED'
    ;

as_subquery_clause =
    [left_paren column_name_list right_paren] 'AS' table_subquery
        with_or_without_data
    ;

with_or_without_data =
    'WITH' 'NO' 'DATA'
  | 'WITH' 'DATA'
    ;

table_period_definition =
    system_or_application_time_period_specification
        left_paren period_begin_column_name comma period_end_column_name right_paren
    ;

system_or_application_time_period_specification =
    system_time_period_specification
  | application_time_period_specification
    ;

system_time_period_specification =
    'PERIOD' 'FOR' 'SYSTEM_TIME'
    ;

application_time_period_specification =
    'PERIOD' 'FOR' application_time_period_name
    ;

application_time_period_name =
    identifier
    ;

period_begin_column_name =
    column_name
    ;

period_end_column_name =
    column_name
    ;

# 11.4 column_definition

# Function
# Define a column of a base table.

# Format
column_definition =
    column_name [data_type_or_domain_name]
        [default_clause | identity_column_specification | generation_clause
          | system_time_period_start_column_specification | system_time_period_end_column_specification]
        [{column_constraint_definition}+]
        [collate_clause]
    ;

data_type_or_domain_name =
    data_type
  | domain_name
    ;

system_time_period_start_column_specification =
    timestamp_generation_rule 'AS' 'ROW' 'START'
    ;

system_time_period_end_column_specification =
    timestamp_generation_rule 'AS' 'ROW' 'END'
    ;

timestamp_generation_rule =
    'GENERATED' 'ALWAYS'
    ;

column_constraint_definition =
    [constraint_name_definition] column_constraint [constraint_characteristics]
    ;

column_constraint =
    'NOT' 'NULL'
  | unique_specification
  | references_specification
  | check_constraint_definition
    ;

identity_column_specification =
    'GENERATED' ('ALWAYS' | 'BY' 'DEFAULT') 'AS' 'IDENTITY'
        [left_paren common_sequence_generator_options right_paren]
    ;

generation_clause =
    generation_rule 'AS' generation_expression
    ;

generation_rule =
    'GENERATED' 'ALWAYS'
    ;

generation_expression =
    left_paren value_expression right_paren
    ;

# 11.5 default_clause

# Function
# Specify the default for a column, domain, or attribute.

# Format
default_clause =
    'DEFAULT' default_option
    ;

default_option =
    literal
  | datetime_value_function
  | 'USER'
  | 'CURRENT_USER'
  | 'CURRENT_ROLE'
  | 'SESSION_USER'
  | 'SYSTEM_USER'
  | 'CURRENT_CATALOG'
  | 'CURRENT_SCHEMA'
  | 'CURRENT_PATH'
  | implicitly_typed_value_specification
    ;

# 11.6 table_constraint_definition

# Function
# Specify an integrity constraint.

# Format
table_constraint_definition =
    [constraint_name_definition] table_constraint
        [constraint_characteristics]
    ;

table_constraint =
    unique_constraint_definition
  | referential_constraint_definition
  | check_constraint_definition
    ;

# 11.7 unique_constraint_definition

# Function
# Specify a uniqueness constraint for a table.

# Format
unique_constraint_definition =
    unique_specification left_paren unique_column_list [comma without_overlap_specification] right_paren
  | 'UNIQUE' ('VALUE')
    ;

unique_specification =
    'UNIQUE'
  | 'PRIMARY' 'KEY'
    ;

unique_column_list =
    column_name_list
    ;

without_overlap_specification =
    application_time_period_name 'WITHOUT' 'OVERLAPS'
    ;

# 11.8 referential_constraint_definition

# Function
# Specify a referential constraint.

# Format
referential_constraint_definition =
    'FOREIGN' 'KEY' left_paren referencing_column_list
        [comma referencing_period_specification] right_paren
        references_specification
    ;

references_specification =
    'REFERENCES' referenced_table_and_columns
        ['MATCH' match_type] [referential_triggered_action]
    ;

match_type =
    'FULL'
  | 'PARTIAL'
  | 'SIMPLE'
    ;

referencing_column_list =
    column_name_list
    ;

referencing_period_specification =
    'PERIOD' application_time_period_name
    ;

referenced_table_and_columns =
    table_name [left_paren referenced_column_list
        [comma referenced_period_specification] right_paren]
    ;

referenced_column_list =
    column_name_list
    ;

referenced_period_specification =
    'PERIOD' application_time_period_name
    ;

referential_triggered_action =
    update_rule [delete_rule]
  | delete_rule [update_rule]
    ;

update_rule =
    'ON' 'UPDATE' referential_action
    ;

delete_rule =
    'ON' 'DELETE' referential_action
    ;

referential_action =
    'CASCADE'
  | 'SET' 'NULL'
  | 'SET' 'DEFAULT'
  | 'RESTRICT'
  | 'NO' 'ACTION'
    ;

# 11.9 check_constraint_definition

# Function
# Specify a condition for the SQL-data.

# Format
check_constraint_definition =
    'CHECK' left_paren search_condition right_paren
    ;

# 11.10 alter_table_statement

# Function
# Change the definition of a table.

# Format
alter_table_statement =
    'ALTER' 'TABLE' table_name alter_table_action
    ;

alter_table_action =
    add_column_definition
  | alter_column_definition
  | drop_column_definition
  | add_table_constraint_definition
  | alter_table_constraint_definition
  | drop_table_constraint_definition
  | add_table_period_definition
  | drop_table_period_definition
  | add_system_versioning_clause
  | drop_system_versioning_clause
    ;

# 11.11 add_column_definition

# Function
# Add a column to a table.

# Format
add_column_definition =
    'ADD' ['COLUMN'] column_definition
    ;

# 11.12 alter_column_definition

# Function
# Change a column and its definition.

# Format
alter_column_definition =
        'ALTER' ['COLUMN'] column_name alter_column_action
    ;

alter_column_action =
    set_column_default_clause
  | drop_column_default_clause
  | set_column_not_null_clause
  | drop_column_not_null_clause
  | add_column_scope_clause
  | drop_column_scope_clause
  | alter_column_data_type_clause
  | alter_identity_column_specification
  | drop_identity_property_clause
  | drop_column_generation_expression_clause
    ;

# 11.13 set_column_default_clause

# Function
# Set the default clause for a column.

# Format
set_column_default_clause =
    'SET' default_clause
    ;

# 11.14 drop_column_default_clause

# Function
# Drop the default clause from a column.

# Format
drop_column_default_clause =
    'DROP' 'DEFAULT'
    ;

# 11.15 set_column_not_null_clause

# Function
# Add a not null constraint to a column.

# Format
set_column_not_null_clause =
    'SET' 'NOT' 'NULL'
    ;

# 11.16 drop_column_not_null_clause

# Function
# Drop a not null constraint on a column.

# Format
drop_column_not_null_clause =
    'DROP' 'NOT' 'NULL'
    ;

# 11.17 add_column_scope_clause

# Function
# Add a non-empty scope for an existing column of data type REF in a base
# table.

# Format
add_column_scope_clause =
    'ADD' scope_clause
    ;

# 11.18 drop_column_scope_clause

# Function
# Drop the scope from an existing column of data type REF in a base table.

# Format
drop_column_scope_clause =
    'DROP' 'SCOPE' drop_behavior
    ;

# 11.19 alter_column_data_type_clause

# Function
# Change the declared type of a column.

# Format
alter_column_data_type_clause =
    'SET' 'DATA' 'TYPE' data_type
    ;

# 11.20 alter_identity_column_specification

# Function
# Change the options specified for an identity column.

# Format
alter_identity_column_specification =
    set_identity_column_generation_clause [{alter_identity_column_option}+]
  | {alter_identity_column_option}+
    ;

set_identity_column_generation_clause =
    'SET' 'GENERATED' ('ALWAYS' | 'BY' 'DEFAULT')
    ;

alter_identity_column_option =
    alter_sequence_generator_restart_option
  | 'SET' basic_sequence_generator_option
    ;

# 11.21 drop_identity_property_clause

# Function
# Convert an identity column to a column that is not an identity column.

# Format
drop_identity_property_clause =
    'DROP' 'IDENTITY'
    ;

# 11.22 drop_column_generation_expression_clause

# Function
# Convert a generated column to a column that is not a generated column.

# Format
drop_column_generation_expression_clause =
    'DROP' 'EXPRESSION'
    ;

# 11.23 drop_column_definition

# Function
# Destroy a column of a base table.

# Format
drop_column_definition =
    'DROP' ['COLUMN'] column_name drop_behavior
    ;

# 11.24 add_table_constraint_definition

# Function
# Add a constraint to a table.

# Format
add_table_constraint_definition =
    'ADD' table_constraint_definition
    ;

# 11.25 alter_table_constraint_definition

# Function
# Change the definition of a table constraint.

# Format
alter_table_constraint_definition =
    'ALTER' 'CONSTRAINT' constraint_name constraint_enforcement
    ;

# 11.26 drop_table_constraint_definition

# Function
# Destroy a constraint on a table.

# Format
drop_table_constraint_definition =
    'DROP' 'CONSTRAINT' constraint_name drop_behavior
    ;

# 11.27 add_table_period_definition

# Function
# Add a system-time period or an application-time period to a persistent base
# table.

# Format
add_table_period_definition =
    'ADD' table_period_definition [add_system_time_period_column_list]
    ;

add_system_time_period_column_list =
    'ADD' ['COLUMN'] column_definition_1 'ADD' ['COLUMN'] column_definition_2
    ;

column_definition_1 =
    column_definition
    ;

column_definition_2 =
    column_definition
    ;

# 11.28 drop_table_period_definition

# Function
# Remove a system-time period or application-time period from a persistent base
# table.

# Format
drop_table_period_definition =
    'DROP' system_or_application_time_period_specification drop_behavior
    ;

# 11.29 add_system_versioning_clause

# Function
# Alter a regular persistent base table to a system-versioned table.

# Format
add_system_versioning_clause =
    'ADD' system_versioning_clause
    ;

# 11.30 drop_system_versioning_clause

# Function
# Change a system-versioned table into a regular persistent base table.

# Format
drop_system_versioning_clause =
    'DROP' 'SYSTEM' 'VERSIONING' drop_behavior
    ;

# 11.31 drop_table_statement

# Function
# Destroy a table.

# Format
drop_table_statement =
    'DROP' 'TABLE' table_name drop_behavior
    ;

# 11.32 view_definition

# Function
# Define a viewed table.

# Format
view_definition =
    'CREATE' ['RECURSIVE'] 'VIEW' table_name view_specification
        'AS' query_expression ['WITH' [levels_clause] 'CHECK' 'OPTION']
    ;

view_specification =
    regular_view_specification
  | referenceable_view_specification
    ;

regular_view_specification =
    [left_paren view_column_list right_paren]
    ;

referenceable_view_specification =
    'OF' path_resolved_user_defined_type_name [subview_clause]
        [view_element_list]
    ;

subview_clause =
    'UNDER' table_name
    ;

view_element_list =
    left_paren ','.{view_element} right_paren
    ;

view_element =
    self_referencing_column_specification
  | view_column_option
    ;

view_column_option =
    column_name 'WITH' 'OPTIONS' scope_clause
    ;

levels_clause =
    'CASCADED'
  | 'LOCAL'
    ;

view_column_list =
    column_name_list
    ;

# 11.33 drop_view_statement

# Function
# Destroy a view.

# Format
drop_view_statement =
    'DROP' 'VIEW' table_name drop_behavior
    ;

# 11.34 domain_definition

# Function
# Define a domain.

# Format
domain_definition =
    'CREATE' 'DOMAIN' domain_name ['AS'] predefined_type
        [default_clause]
        [{domain_constraint}+]
        [collate_clause]
    ;

domain_constraint =
    [constraint_name_definition] check_constraint_definition [constraint_characteristics]
    ;

# 11.35 alter_domain_statement

# Function
# Change a domain and its definition.

# Format
alter_domain_statement =
    'ALTER' 'DOMAIN' domain_name alter_domain_action
    ;

alter_domain_action =
    set_domain_default_clause
  | drop_domain_default_clause
  | add_domain_constraint_definition
  | drop_domain_constraint_definition
    ;

# 11.36 set_domain_default_clause

# Function
# Set the default value in a domain.

# Format
set_domain_default_clause =
    'SET' default_clause
    ;

# 11.37 drop_domain_default_clause

# Function
# Remove the default clause of a domain.

# Format
drop_domain_default_clause =
    'DROP' 'DEFAULT'
    ;

# 11.38 add_domain_constraint_definition

# Function
# Add a constraint to a domain.

# Format
add_domain_constraint_definition =
    'ADD' domain_constraint
    ;

# 11.39 drop_domain_constraint_definition

# Function
# Destroy a constraint on a domain.

# Format
drop_domain_constraint_definition =
    'DROP' 'CONSTRAINT' constraint_name
    ;

# 11.40 drop_domain_statement

# Function
# Destroy a domain.

# Format
drop_domain_statement =
    'DROP' 'DOMAIN' domain_name drop_behavior
    ;

# 11.41 character_set_definition

# Function
# Define a character set.

# Format
character_set_definition =
    'CREATE' 'CHARACTER' 'SET' character_set_name ['AS']
        character_set_source [collate_clause]
    ;

character_set_source =
    'GET' character_set_specification
    ;

# 11.42 drop_character_set_statement

# Function
# Destroy a character set.

# Format
drop_character_set_statement =
    'DROP' 'CHARACTER' 'SET' character_set_name
    ;

# 11.43 collation_definition

# Function
# Define a collation.

# Format
collation_definition =
    'CREATE' 'COLLATION' collation_name 'FOR' character_set_specification
        'FROM' existing_collation_name [pad_characteristic]
    ;

existing_collation_name =
    collation_name
    ;

pad_characteristic =
    'NO' 'PAD'
  | 'PAD' 'SPACE'
    ;

# 11.44 drop_collation_statement

# Function
# Destroy a collation.

# Format
drop_collation_statement =
    'DROP' 'COLLATION' collation_name drop_behavior
    ;

# 11.45 transliteration_definition

# Function
# Define a character transliteration.

# Format
transliteration_definition =
    'CREATE' 'TRANSLATION' transliteration_name
        'FOR' source_character_set_specification
        'TO' target_character_set_specification
        'FROM' transliteration_source
    ;

source_character_set_specification =
    character_set_specification
    ;

target_character_set_specification =
    character_set_specification
    ;

transliteration_source =
    existing_transliteration_name
  | transliteration_routine
    ;

existing_transliteration_name =
    transliteration_name
    ;

transliteration_routine =
    specific_routine_designator
    ;

# 11.46 drop_transliteration_statement

# Function
# Destroy a character transliteration.

# Format
drop_transliteration_statement =
    'DROP' 'TRANSLATION' transliteration_name
    ;

# 11.47 assertion_definition

# Function
# Specify an integrity constraint.

# Format
assertion_definition =
    'CREATE' 'ASSERTION' constraint_name
        'CHECK' left_paren search_condition right_paren
        [constraint_characteristics]
    ;

# 11.48 drop_assertion_statement

# Function
# Destroy an assertion.

# Format
drop_assertion_statement =
    'DROP' 'ASSERTION' constraint_name [drop_behavior]
    ;

# 11.49 trigger_definition

# Function
# Define triggered SQL-statements.

# Format
trigger_definition =
    'CREATE' 'TRIGGER' trigger_name trigger_action_time trigger_event
        'ON' table_name ['REFERENCING' transition_table_or_variable_list]
        triggered_action
    ;

trigger_action_time =
    'BEFORE'
  | 'AFTER'
  | 'INSTEAD' 'OF'
    ;

trigger_event =
    'INSERT'
  | 'DELETE'
  | 'UPDATE' ['OF' trigger_column_list]
    ;

trigger_column_list =
    column_name_list
    ;

triggered_action =
    ['FOR' 'EACH' ('ROW' | 'STATEMENT')]
        [triggered_when_clause]
        triggered_sql_statement
    ;

triggered_when_clause =
    'WHEN' left_paren search_condition right_paren
    ;

triggered_sql_statement =
    sql_procedure_statement
  | 'BEGIN' 'ATOMIC' {sql_procedure_statement semicolon}+  'END'
    ;

transition_table_or_variable_list =
    {transition_table_or_variable}+
    ;

transition_table_or_variable =
    'OLD' ['ROW'] ['AS'] old_transition_variable_name
  | 'NEW' ['ROW'] ['AS'] new_transition_variable_name
  | 'OLD' 'TABLE' ['AS'] old_transition_table_name
  | 'NEW' 'TABLE' ['AS'] new_transition_table_name
    ;

old_transition_table_name =
    transition_table_name
    ;

new_transition_table_name =
    transition_table_name
    ;

transition_table_name =
    identifier
    ;

old_transition_variable_name =
    correlation_name
    ;

new_transition_variable_name =
    correlation_name
    ;

# 11.50 drop_trigger_statement

# Function
# Destroy a trigger.

# Format
drop_trigger_statement =
    'DROP' 'TRIGGER' trigger_name
    ;

# 11.51 user_defined_type_definition

# Function
# Define a user-defined type.

# Format
user_defined_type_definition =
    'CREATE' 'TYPE' user_defined_type_body
    ;

user_defined_type_body =
    schema_resolved_user_defined_type_name
        [subtype_clause]
        ['AS' representation]
        [user_defined_type_option_list]
        [method_specification_list]
    ;

user_defined_type_option_list =
    user_defined_type_option [{user_defined_type_option}+]
    ;

user_defined_type_option =
    instantiable_clause
  | finality
  | reference_type_specification
  | cast_to_ref
  | cast_to_type
  | cast_to_distinct
  | cast_to_source
    ;

subtype_clause =
    'UNDER' supertype_name
    ;

supertype_name =
    path_resolved_user_defined_type_name
    ;

representation =
    predefined_type
  | collection_type
  | member_list
    ;

member_list =
    left_paren ','.{member} right_paren
    ;

member =
    attribute_definition
    ;

instantiable_clause =
    'INSTANTIABLE'
  | 'NOT' 'INSTANTIABLE'
    ;

finality =
    'FINAL'
  | 'NOT' 'FINAL'
    ;

reference_type_specification =
    user_defined_representation
  | derived_representation
  | system_generated_representation
    ;

user_defined_representation =
    'REF' 'USING' predefined_type
    ;

derived_representation =
    'REF' 'FROM' list_of_attributes
    ;

system_generated_representation =
    'REF' 'IS' 'SYSTEM' 'GENERATED'
    ;

cast_to_ref =
    'CAST' left_paren 'SOURCE' 'AS' 'REF' right_paren 'WITH' cast_to_ref_identifier
    ;

cast_to_ref_identifier =
    identifier
    ;

cast_to_type =
    'CAST' left_paren 'REF' 'AS' 'SOURCE' right_paren 'WITH' cast_to_type_identifier
    ;

cast_to_type_identifier =
    identifier
    ;

list_of_attributes =
    left_paren ','.{attribute_name} right_paren
    ;

cast_to_distinct =
    'CAST' left_paren 'SOURCE' 'AS' 'DISTINCT' right_paren
        'WITH' cast_to_distinct_identifier
    ;

cast_to_distinct_identifier =
    identifier
    ;

cast_to_source =
    'CAST' left_paren 'DISTINCT' 'AS' 'SOURCE' right_paren
        'WITH' cast_to_source_identifier
    ;

cast_to_source_identifier =
    identifier
    ;

method_specification_list =
    ','.{method_specification}
    ;

method_specification =
    original_method_specification
  | overriding_method_specification
    ;

original_method_specification =
    partial_method_specification
        ['SELF' 'AS' 'RESULT']
        ['SELF' 'AS' 'LOCATOR']
        [method_characteristics]
    ;

overriding_method_specification =
    'OVERRIDING' partial_method_specification
    ;

partial_method_specification =
    ['INSTANCE' | 'STATIC' | 'CONSTRUCTOR']
        'METHOD' method_name sql_parameter_declaration_list
        returns_clause ['SPECIFIC' specific_method_name]
    ;

specific_method_name =
    [schema_name period] qualified_identifier
    ;

method_characteristics =
    {method_characteristic}+
    ;

method_characteristic =
    language_clause
  | parameter_style_clause
  | deterministic_characteristic
  | sql_data_access_indication
  | null_call_clause
    ;

# 11.52 attribute_definition

# Function
# Define an attribute of a structured type.

# Format
attribute_definition =
    attribute_name data_type
        [attribute_default]
        [collate_clause]
    ;

attribute_default =
    default_clause
    ;

# 11.53 alter_type_statement

# Function
# Change the definition of a user-defined type.

# Format
alter_type_statement =
    'ALTER' 'TYPE' schema_resolved_user_defined_type_name alter_type_action
    ;

alter_type_action =
    add_attribute_definition
  | drop_attribute_definition
  | add_original_method_specification
  | add_overriding_method_specification
  | drop_method_specification
    ;

# 11.54 add_attribute_definition

# Function
# Add an attribute to a user-defined type.

# Format
add_attribute_definition =
    'ADD' 'ATTRIBUTE' attribute_definition
    ;

# 11.55 drop_attribute_definition

# Function
# Destroy an attribute of a user-defined type.

# Format
drop_attribute_definition =
    'DROP' 'ATTRIBUTE' attribute_name 'RESTRICT'
    ;

# 11.56 add_original_method_specification

# Function
# Add an original method specification to a user-defined type.

# Format
add_original_method_specification =
    'ADD' original_method_specification
    ;

# 11.57 add_overriding_method_specification

# Function
# Add an overriding method specification to a user-defined type.

# Format
add_overriding_method_specification =
    'ADD' overriding_method_specification
    ;

# 11.58 drop_method_specification

# Function
# Remove a method specification from a user-defined type.

# Format
drop_method_specification =
    'DROP' specific_method_specification_designator 'RESTRICT'
    ;

specific_method_specification_designator =
    ['INSTANCE' | 'STATIC' | 'CONSTRUCTOR']
        'METHOD' method_name data_type_list
    ;

# 11.59 drop_data_type_statement

# This Subclause is modified by Subclause 9.23, drop_data_type_statement,
# in 'ISO'/'IEC' 9075-4.
# This Subclause is modified by Subclause 9.7, drop_data_type_statement,
# in 'ISO'/'IEC' 9075-13.

# Function
# Destroy a user-defined type.

# Format
drop_data_type_statement =
    'DROP' 'TYPE' schema_resolved_user_defined_type_name drop_behavior
    ;

# 11.60 sql_invoked_routine

# Function
# Define an SQL-invoked routine.

# Format
sql_invoked_routine =
    schema_routine
    ;

schema_routine =
    schema_procedure
  | schema_function
    ;

schema_procedure =
    'CREATE' sql_invoked_procedure
    ;

schema_function =
    'CREATE' sql_invoked_function
    ;

sql_invoked_procedure =
    'PROCEDURE' schema_qualified_routine_name
        sql_parameter_declaration_list
        routine_characteristics
        routine_body
    ;

sql_invoked_function =
    (function_specification | method_specification_designator) routine_body
    ;

sql_parameter_declaration_list =
    left_paren [','.{sql_parameter_declaration}] right_paren
    ;

sql_parameter_declaration =
    [parameter_mode]
        [sql_parameter_name]
        parameter_type ['RESULT']
        ['DEFAULT' parameter_default]
    ;

parameter_default =
    value_expression
  | contextually_typed_value_specification
    ;

parameter_mode =
    'IN'
  | 'OUT'
  | 'INOUT'
    ;

parameter_type =
    data_type [locator_indication]
    ;

locator_indication =
    'AS' 'LOCATOR'
    ;

function_specification =
    'FUNCTION' schema_qualified_routine_name
        sql_parameter_declaration_list
        returns_clause
        routine_characteristics
        [dispatch_clause]
    ;

method_specification_designator =
    'SPECIFIC' 'METHOD' specific_method_name
  | ['INSTANCE' | 'STATIC' | 'CONSTRUCTOR']
        'METHOD' method_name sql_parameter_declaration_list
        [returns_clause]
        'FOR' schema_resolved_user_defined_type_name
    ;

routine_characteristics =
    [{routine_characteristic}+]
    ;

routine_characteristic =
    language_clause
  | parameter_style_clause
  | 'SPECIFIC' specific_name
  | deterministic_characteristic
  | sql_data_access_indication
  | null_call_clause
  | returned_result_sets_characteristic
  | savepoint_level_indication
    ;

savepoint_level_indication =
    'NEW' 'SAVEPOINT' 'LEVEL'
  | 'OLD' 'SAVEPOINT' 'LEVEL'
    ;

returned_result_sets_characteristic =
    'DYNAMIC' 'RESULT' 'SETS' maximum_returned_result_sets
    ;

parameter_style_clause =
    'PARAMETER' 'STYLE' parameter_style
    ;

dispatch_clause =
    'STATIC' 'DISPATCH'
    ;

returns_clause =
    'RETURNS' returns_type
    ;

returns_type =
    returns_data_type [result_cast]
  | returns_table_type
    ;

returns_table_type =
    'TABLE' table_function_column_list
    ;

table_function_column_list =
    left_paren ','.{table_function_column_list_element} right_paren
    ;

table_function_column_list_element =
    column_name data_type
    ;

result_cast =
    'CAST' 'FROM' result_cast_from_type
    ;

result_cast_from_type =
    data_type [locator_indication]
    ;

returns_data_type =
    data_type [locator_indication]
    ;

routine_body =
    sql_routine_spec
  | external_body_reference
    ;

sql_routine_spec =
    [rights_clause] sql_routine_body
    ;

rights_clause =
    'SQL' 'SECURITY' 'INVOKER'
  | 'SQL' 'SECURITY' 'DEFINER'
    ;

sql_routine_body =
    sql_procedure_statement
    ;

external_body_reference =
    'EXTERNAL' ['NAME' external_routine_name]
        [parameter_style_clause]
        [transform_group_specification]
        [external_security_clause]
    ;

external_security_clause =
    'EXTERNAL' 'SECURITY' 'DEFINER'
  | 'EXTERNAL' 'SECURITY' 'INVOKER'
  | 'EXTERNAL' 'SECURITY' 'IMPLEMENTATION' 'DEFINED'
    ;

parameter_style =
    'SQL'
  | 'GENERAL'
    ;

deterministic_characteristic =
    'DETERMINISTIC'
  | 'NOT' 'DETERMINISTIC'
    ;

sql_data_access_indication =
    'NO' 'SQL'
  | 'CONTAINS' 'SQL'
  | 'READS' 'SQL' 'DATA'
  | 'MODIFIES' 'SQL' 'DATA'
    ;

null_call_clause =
    'RETURNS' 'NULL' 'ON' 'NULL' 'INPUT'
  | 'CALLED' 'ON' 'NULL' 'INPUT'
    ;

maximum_returned_result_sets =
    unsigned_integer
    ;

transform_group_specification =
    'TRANSFORM' 'GROUP' (single_group_specification | multiple_group_specification)
    ;

single_group_specification =
    group_name
    ;

multiple_group_specification =
    ','.{group_specification}
    ;

group_specification =
    group_name 'FOR' 'TYPE' path_resolved_user_defined_type_name
    ;

# 11.61 alter_routine_statement

# Function
# Alter a characteristic of an SQL-invoked routine.

# Format
alter_routine_statement =
    'ALTER' specific_routine_designator
        alter_routine_characteristics alter_routine_behavior
    ;

alter_routine_characteristics =
    {alter_routine_characteristic}+
    ;

alter_routine_characteristic =
    language_clause
  | parameter_style_clause
  | sql_data_access_indication
  | null_call_clause
  | returned_result_sets_characteristic
  | 'NAME' external_routine_name
    ;

alter_routine_behavior =
    'RESTRICT'
    ;

# 11.62 drop_routine_statement

# Function
# Destroy an SQL-invoked routine.

# Format
drop_routine_statement =
    'DROP' specific_routine_designator drop_behavior
    ;

# 11.63 user_defined_cast_definition

# Function
# Define a user-defined cast.

# Format
user_defined_cast_definition =
    'CREATE' 'CAST' left_paren source_data_type
        'AS' target_data_type right_paren
        'WITH' cast_function
        ['AS' 'ASSIGNMENT']
    ;

cast_function =
    specific_routine_designator
    ;

source_data_type =
    data_type
    ;

target_data_type =
    data_type
    ;

# 11.64 drop_user_defined_cast_statement

# Function
# Destroy a user-defined cast.

# Format
drop_user_defined_cast_statement =
    'DROP' 'CAST' left_paren source_data_type
        'AS' target_data_type right_paren
        drop_behavior
    ;

# 11.65 user_defined_ordering_definition

# Function
# Define a user-defined ordering for a user-defined type.

# Format
user_defined_ordering_definition =
    'CREATE' 'ORDERING' 'FOR'
        schema_resolved_user_defined_type_name ordering_form
    ;

ordering_form =
    equals_ordering_form
  | full_ordering_form
    ;

equals_ordering_form =
    'EQUALS' 'ONLY' 'BY' ordering_category
    ;

full_ordering_form =
    'ORDER' 'FULL' 'BY' ordering_category
    ;

ordering_category =
    relative_category
  | map_category
  | state_category
    ;

relative_category =
    'RELATIVE' 'WITH' relative_function_specification
    ;

map_category =
    'MAP' 'WITH' map_function_specification
    ;

state_category =
    'STATE' [specific_name]
    ;

relative_function_specification =
    specific_routine_designator
    ;

map_function_specification =
    specific_routine_designator
    ;

# 11.66 drop_user_defined_ordering_statement

# Function
# Destroy a user-defined ordering method.

# Format
drop_user_defined_ordering_statement =
    'DROP' 'ORDERING' 'FOR'
        schema_resolved_user_defined_type_name drop_behavior
    ;

# 11.67 transform_definition

# Function
# Define one or more transform functions for a user-defined type.

# Format
transform_definition =
    'CREATE' ('TRANSFORM' | 'TRANSFORMS') 'FOR'
        schema_resolved_user_defined_type_name {transform_group}+
    ;

transform_group =
    group_name left_paren transform_element_list right_paren
    ;

group_name =
    identifier
    ;

transform_element_list =
    transform_element [comma transform_element]
    ;

transform_element =
    to_sql
  | from_sql
    ;

to_sql =
    'TO' 'SQL' 'WITH' to_sql_function
    ;

from_sql =
    'FROM' 'SQL' 'WITH' from_sql_function
    ;

to_sql_function =
    specific_routine_designator
    ;

from_sql_function =
    specific_routine_designator
    ;

# 11.68 alter_transform_statement

# Function
# Change the definition of one or more transform groups.

# Format
alter_transform_statement =
    'ALTER' ('TRANSFORM' | 'TRANSFORMS')
        'FOR' schema_resolved_user_defined_type_name {alter_group}+
    ;

alter_group =
    group_name left_paren alter_transform_action_list right_paren
    ;

alter_transform_action_list =
    ','.{alter_transform_action}
    ;

alter_transform_action =
    add_transform_element_list
  | drop_transform_element_list
    ;

# 11.69 add_transform_element_list

# Function
# Add a transform element (to_sql and/or from_sql) to an existing transform
# group.

# Format
add_transform_element_list =
    'ADD' left_paren transform_element_list right_paren
    ;

# 11.70 drop_transform_element_list

# Function
# Remove a transform element (to_sql and/or from_sql) from a transform group.

# Format
drop_transform_element_list =
    'DROP' left_paren transform_kind
        [comma transform_kind] drop_behavior right_paren
    ;

transform_kind =
    'TO' 'SQL'
  | 'FROM' 'SQL'
    ;

# 11.71 drop_transform_statement

# Function
# Remove one or more transform functions associated with a transform.

# Format
drop_transform_statement =
    'DROP' ('TRANSFORM' | 'TRANSFORMS') transforms_to_be_dropped
        'FOR' schema_resolved_user_defined_type_name drop_behavior
    ;

transforms_to_be_dropped =
    'ALL'
  | transform_group_element
    ;

transform_group_element =
    group_name
    ;

# 11.72 sequence_generator_definition

# Function
# Define an external sequence generator.

# Format
sequence_generator_definition =
    'CREATE' 'SEQUENCE' sequence_generator_name
        [sequence_generator_options]
    ;

sequence_generator_options =
    {sequence_generator_option}+
    ;

sequence_generator_option =
    sequence_generator_data_type_option
  | common_sequence_generator_options
    ;

common_sequence_generator_options =
    {common_sequence_generator_option}+
    ;

common_sequence_generator_option =
    sequence_generator_start_with_option
  | basic_sequence_generator_option
    ;

basic_sequence_generator_option =
    sequence_generator_increment_by_option
  | sequence_generator_maxvalue_option
  | sequence_generator_minvalue_option
  | sequence_generator_cycle_option
    ;

sequence_generator_data_type_option =
    'AS' data_type
    ;

sequence_generator_start_with_option =
    'START' 'WITH' sequence_generator_start_value
    ;

sequence_generator_start_value =
    signed_numeric_literal
    ;

sequence_generator_increment_by_option =
    'INCREMENT' 'BY' sequence_generator_increment
    ;

sequence_generator_increment =
    signed_numeric_literal
    ;

sequence_generator_maxvalue_option =
    'MAXVALUE' sequence_generator_max_value
  | 'NO' 'MAXVALUE'
    ;

sequence_generator_max_value =
    signed_numeric_literal
    ;

sequence_generator_minvalue_option =
    'MINVALUE' sequence_generator_min_value
  | 'NO' 'MINVALUE'
    ;

sequence_generator_min_value =
    signed_numeric_literal
    ;

sequence_generator_cycle_option =
    'CYCLE'
  | 'NO' 'CYCLE'
    ;

# 11.73 alter_sequence_generator_statement

# Function
# Change the definition of an external sequence generator.

# Format
alter_sequence_generator_statement =
    'ALTER' 'SEQUENCE' sequence_generator_name
        alter_sequence_generator_options
    ;

alter_sequence_generator_options =
    {alter_sequence_generator_option}+
    ;

alter_sequence_generator_option =
    alter_sequence_generator_restart_option
  | basic_sequence_generator_option
    ;

alter_sequence_generator_restart_option =
    'RESTART' ['WITH' sequence_generator_restart_value]
    ;

sequence_generator_restart_value =
    signed_numeric_literal
    ;

# 11.74 drop_sequence_generator_statement

# Function
# Destroy an external sequence generator.

# Format
drop_sequence_generator_statement =
    'DROP' 'SEQUENCE' sequence_generator_name drop_behavior
    ;

# 12 Access control

# 12.1 grant_statement

# Function
# Define privileges and role authorizations.

# Format
grant_statement =
    grant_privilege_statement
  | grant_role_statement
    ;

# 12.2 grant_privilege_statement

# Function
# Define privileges.

# Format
grant_privilege_statement =
    'GRANT' privileges 'TO' ','.{grantee}
        ['WITH' 'HIERARCHY' 'OPTION']
        ['WITH' 'GRANT' 'OPTION']
        ['GRANTED' 'BY' grantor]
    ;

# 12.3 privileges

# Function
# Specify privileges.

# Format
privileges =
    object_privileges 'ON' object_name
    ;

object_name =
    ['TABLE'] table_name
  | 'DOMAIN' domain_name
  | 'COLLATION' collation_name
  | 'CHARACTER' 'SET' character_set_name
  | 'TRANSLATION' transliteration_name
  | 'TYPE' schema_resolved_user_defined_type_name
  | 'SEQUENCE' sequence_generator_name
  | specific_routine_designator
    ;

object_privileges =
    'ALL' 'PRIVILEGES'
  | ','.{action}
    ;

action =
    'SELECT'
  | 'SELECT' left_paren privilege_column_list right_paren
  | 'SELECT' left_paren privilege_method_list right_paren
  | 'DELETE'
  | 'INSERT' [left_paren privilege_column_list right_paren]
  | 'UPDATE' [left_paren privilege_column_list right_paren]
  | 'REFERENCES' [left_paren privilege_column_list right_paren]
  | 'USAGE'
  | 'TRIGGER'
  | 'UNDER'
  | 'EXECUTE'
    ;

privilege_method_list =
    ','.{specific_routine_designator}
    ;

privilege_column_list =
    column_name_list
    ;

grantee =
    'PUBLIC'
  | authorization_identifier
    ;

grantor =
    'CURRENT_USER'
  | 'CURRENT_ROLE'
    ;

# 12.4 role_definition

# Function
# Define a role.

# Format
role_definition =
    'CREATE' 'ROLE' role_name ['WITH' 'ADMIN' grantor]
    ;

# 12.5 grant_role_statement

# Function
# Define role authorizations.

# Format
grant_role_statement =
    'GRANT' ','.{role_granted}
        'TO' ','.{grantee}
        ['WITH' 'ADMIN' 'OPTION']
        ['GRANTED' 'BY' grantor]
    ;

role_granted =
    role_name
    ;

# 12.6 drop_role_statement

# Function
# Destroy a role.

# Format
drop_role_statement =
    'DROP' 'ROLE' role_name
    ;

# 12.7 revoke_statement

# Function
# Destroy privileges and role authorizations.

# Format
revoke_statement =
    revoke_privilege_statement
  | revoke_role_statement
    ;

revoke_privilege_statement =
    'REVOKE' [revoke_option_extension] privileges
        'FROM' ','.{grantee}
        ['GRANTED' 'BY' grantor]
        drop_behavior
    ;

revoke_option_extension =
    'GRANT' 'OPTION' 'FOR'
  | 'HIERARCHY' 'OPTION' 'FOR'
    ;

revoke_role_statement =
    'REVOKE' ['ADMIN' 'OPTION' 'FOR'] ','.{role_revoked}
        'FROM' ','.{grantee}
        ['GRANTED' 'BY' grantor]
        drop_behavior
    ;

role_revoked =
    role_name
    ;

# 13 SQL-client modules

# 13.1 sql_client_module_definition

# Function
# Define an SQL-client module.

# Format
sql_client_module_definition =
    module_name_clause language_clause module_authorization_clause
        [module_path_specification]
        [module_transform_group_specification]
        [module_collations]
        [{temporary_table_declaration}+]
        {module_contents}+
    ;

module_authorization_clause =
    'SCHEMA' schema_name
  | 'AUTHORIZATION' module_authorization_identifier
        ['FOR' 'STATIC' ('ONLY' | 'AND' 'DYNAMIC')]
  | 'SCHEMA' schema_name 'AUTHORIZATION' module_authorization_identifier
        ['FOR' 'STATIC' ('ONLY' | 'AND' 'DYNAMIC')]
    ;

module_authorization_identifier =
    authorization_identifier
    ;

module_path_specification =
    path_specification
    ;

module_transform_group_specification =
    transform_group_specification
    ;

module_collations =
    {module_collation_specification}+
    ;

module_collation_specification =
    'COLLATION' collation_name ['FOR' character_set_specification_list]
    ;

character_set_specification_list =
    ','.{character_set_specification}
    ;

module_contents =
    declare_cursor
  | dynamic_declare_cursor
  | externally_invoked_procedure
    ;

# 13.2 module_name_clause

# Function
# Name an SQL-client module.

# Format
module_name_clause =
    'MODULE' [sql_client_module_name]
        [module_character_set_specification]
    ;

module_character_set_specification =
    'NAMES' 'ARE' character_set_specification
    ;

# 13.3 externally_invoked_procedure

# Function
# Define an externally-invoked procedure.

# Format
externally_invoked_procedure =
    'PROCEDURE' procedure_name host_parameter_declaration_list semicolon
        sql_procedure_statement semicolon
    ;

host_parameter_declaration_list =
    left_paren ','.{host_parameter_declaration} right_paren
    ;

host_parameter_declaration =
    host_parameter_name host_parameter_data_type
  | status_parameter
    ;

host_parameter_data_type =
    data_type [locator_indication]
    ;

status_parameter =
    'SQLSTATE'
    ;

# 13.4 sql_procedure_statement

# Function
# Define all of the SQL-statements that are sql_procedure_statements.

# Format
sql_procedure_statement =
    sql_executable_statement
    ;

sql_executable_statement =
    sql_schema_statement
  | sql_data_statement
  | sql_control_statement
  | sql_transaction_statement
  | sql_connection_statement
  | sql_session_statement
  | sql_diagnostics_statement
  | sql_dynamic_statement
    ;

sql_schema_statement =
    sql_schema_definition_statement
  | sql_schema_manipulation_statement
    ;

sql_schema_definition_statement =
    schema_definition
  | table_definition
  | view_definition
  | sql_invoked_routine
  | grant_statement
  | role_definition
  | domain_definition
  | character_set_definition
  | collation_definition
  | transliteration_definition
  | assertion_definition
  | trigger_definition
  | user_defined_type_definition
  | user_defined_cast_definition
  | user_defined_ordering_definition
  | transform_definition
  | sequence_generator_definition
    ;

sql_schema_manipulation_statement =
    drop_schema_statement
  | alter_table_statement
  | drop_table_statement
  | drop_view_statement
  | alter_routine_statement
  | drop_routine_statement
  | drop_user_defined_cast_statement
  | revoke_statement
  | drop_role_statement
  | alter_domain_statement
  | drop_domain_statement
  | drop_character_set_statement
  | drop_collation_statement
  | drop_transliteration_statement
  | drop_assertion_statement
  | drop_trigger_statement
  | alter_type_statement
  | drop_data_type_statement
  | drop_user_defined_ordering_statement
  | alter_transform_statement
  | drop_transform_statement
  | alter_sequence_generator_statement
  | drop_sequence_generator_statement
    ;

sql_data_statement =
    open_statement
  | fetch_statement
  | close_statement
  | select_statement_single_row
  | free_locator_statement
  | hold_locator_statement
  | sql_data_change_statement
    ;

sql_data_change_statement =
    delete_statement_positioned
  | delete_statement_searched
  | insert_statement
  | update_statement_positioned
  | update_statement_searched
  | truncate_table_statement
  | merge_statement
    ;

sql_control_statement =
    call_statement
  | return_statement
    ;

sql_transaction_statement =
    start_transaction_statement
  | set_transaction_statement
  | set_constraints_mode_statement
  | savepoint_statement
  | release_savepoint_statement
  | commit_statement
  | rollback_statement
    ;

sql_connection_statement =
    connect_statement
  | set_connection_statement
  | disconnect_statement
    ;

sql_session_statement =
    set_session_user_identifier_statement
  | set_role_statement
  | set_local_time_zone_statement
  | set_session_characteristics_statement
  | set_catalog_statement
  | set_schema_statement
  | set_names_statement
  | set_path_statement
  | set_transform_group_statement
  | set_session_collation_statement
    ;

sql_diagnostics_statement =
    get_diagnostics_statement
    ;

sql_dynamic_statement =
    sql_descriptor_statement
  | prepare_statement
  | deallocate_prepared_statement
  | describe_statement
  | execute_statement
  | execute_immediate_statement
  | sql_dynamic_data_statement
    ;

sql_dynamic_data_statement =
    allocate_extended_dynamic_cursor_statement
  | allocate_received_cursor_statement
  | dynamic_open_statement
  | dynamic_fetch_statement
  | dynamic_close_statement
  | dynamic_delete_statement_positioned
  | dynamic_update_statement_positioned
    ;

sql_descriptor_statement =
    allocate_descriptor_statement
  | deallocate_descriptor_statement
  | set_descriptor_statement
  | get_descriptor_statement
    ;

# 14 Data manipulation

# 14.1 declare_cursor

# Function
# Declare a standing cursor.

# Format
declare_cursor =
    'DECLARE' cursor_name cursor_properties
        'FOR' cursor_specification
    ;

# 14.2 cursor_properties

# Function
# Specify the declared properties of a cursor.

# Format
cursor_properties =
    [cursor_sensitivity] [cursor_scrollability] 'CURSOR'
        [cursor_holdability]
        [cursor_returnability]
    ;

cursor_sensitivity =
    'SENSITIVE'
  | 'INSENSITIVE'
  | 'ASENSITIVE'
    ;

cursor_scrollability =
    'SCROLL'
  | 'NO' 'SCROLL'
    ;

cursor_holdability =
    'WITH' 'HOLD'
  | 'WITHOUT' 'HOLD'
    ;

cursor_returnability =
    'WITH' 'RETURN'
  | 'WITHOUT' 'RETURN'
    ;

# 14.3 cursor_specification

# Function
# Define a result set.

# Format
cursor_specification =
    query_expression [updatability_clause]
    ;

updatability_clause =
    'FOR' ('READ' 'ONLY' | 'UPDATE' ['OF' column_name_list])
    ;

# 14.4 open_statement

# Function
# Open a standing cursor.

# Format
open_statement =
    'OPEN' cursor_name
    ;

# 14.5 fetch_statement

# Function
# Position a standing cursor on a specified row of the standing cursor's result set and retrieve values from that
# row.

# Format
fetch_statement =
    'FETCH' [[fetch_orientation] 'FROM'] cursor_name 'INTO' fetch_target_list
    ;

fetch_orientation =
    'NEXT'
  | 'PRIOR'
  | 'FIRST'
  | 'LAST'
  | ('ABSOLUTE' | 'RELATIVE') simple_value_specification
    ;

fetch_target_list =
    ','.{target_specification}
    ;

# 14.6 close_statement

# Function
# Close a standing cursor.

# Format
close_statement =
    'CLOSE' cursor_name
    ;

# 14.7 select_statement_single_row

# Function
# Retrieve values from a specified row of a table.

# Format
select_statement_single_row =
    'SELECT' [set_quantifier] select_list
        'INTO' select_target_list
        table_expression
    ;

select_target_list =
    ','.{target_specification}
    ;

# 14.8 delete_statement_positioned

# Function
# Delete a row of a table.

# Format
delete_statement_positioned =
    'DELETE' 'FROM' target_table [['AS'] correlation_name]
        'WHERE' 'CURRENT' 'OF' cursor_name
    ;

target_table =
    table_name
  | 'ONLY' left_paren table_name right_paren
    ;

# 14.9 delete_statement_searched

# Function
# Delete rows of a table.

# Format
delete_statement_searched =
    'DELETE' 'FROM' target_table
        ['FOR' 'PORTION' 'OF' application_time_period_name
        'FROM' point_in_time_1 'TO' point_in_time_2]
        [['AS'] correlation_name]
        ['WHERE' search_condition]
    ;

# 14.10 truncate_table_statement

# Function
# Delete all rows of a base table without causing any triggered action.

# Format
truncate_table_statement =
    'TRUNCATE' 'TABLE' target_table [identity_column_restart_option]
    ;

identity_column_restart_option =
    'CONTINUE' 'IDENTITY'
  | 'RESTART' 'IDENTITY'
    ;

# 14.11 insert_statement

# Function
# Create new rows in a table.

# Format
insert_statement =
    'INSERT' 'INTO' insertion_target insert_columns_and_source
    ;

insertion_target =
    table_name
    ;

insert_columns_and_source =
    from_subquery
  | from_constructor
  | from_default
    ;

from_subquery =
    [left_paren insert_column_list right_paren]
        [override_clause]
        query_expression
    ;

from_constructor =
    [left_paren insert_column_list right_paren]
        [override_clause]
        contextually_typed_table_value_constructor
    ;

override_clause =
    'OVERRIDING' 'USER' 'VALUE'
  | 'OVERRIDING' 'SYSTEM' 'VALUE'
    ;

from_default =
    'DEFAULT' 'VALUES'
    ;

insert_column_list =
    column_name_list
    ;

# 14.12 merge_statement

# Function
# Conditionally update and/or delete rows of a table and/or insert new rows into a table.

# Format
merge_statement =
    'MERGE' 'INTO' target_table [['AS'] merge_correlation_name]
        'USING' table_reference
        'ON' search_condition merge_operation_specification
    ;

merge_correlation_name =
    correlation_name
    ;

merge_operation_specification =
    {merge_when_clause}+
    ;

merge_when_clause =
    merge_when_matched_clause
  | merge_when_not_matched_clause
    ;

merge_when_matched_clause =
    'WHEN' 'MATCHED' ['AND' search_condition]
        'THEN' merge_update_or_delete_specification
    ;

merge_update_or_delete_specification =
    merge_update_specification
  | merge_delete_specification
    ;

merge_when_not_matched_clause =
    'WHEN' 'NOT' 'MATCHED' ['AND' search_condition]
        'THEN' merge_insert_specification
    ;

merge_update_specification =
    'UPDATE' 'SET' set_clause_list
    ;

merge_delete_specification =
    'DELETE'
    ;

merge_insert_specification =
    'INSERT' [left_paren insert_column_list right_paren]
        [override_clause]
        'VALUES' merge_insert_value_list
    ;

merge_insert_value_list =
    left_paren
        ','.{merge_insert_value_element}
        right_paren
    ;

merge_insert_value_element =
    value_expression
  | contextually_typed_value_specification
    ;

# 14.13 update_statement_positioned

# Function
# Update a row of a table.

# Format
updatestatement_positioned =
    'UPDATE' target_table [['AS'] correlation_name]
        'SET' set_clause_list
        'WHERE' 'CURRENT' 'OF' cursor_name
    ;

# 14.14 update_statement_searched

# Function
# Update rows of a table.

# Format
update_statement_searched =
    'UPDATE' target_table
        ['FOR' 'PORTION' 'OF' application_time_period_name
        'FROM' point_in_time_1 'TO' point_in_time_2]
        [['AS'] correlation_name]
        'SET' set_clause_list
        ['WHERE' search_condition]
    ;

# 14.15 set_clause_list

# Function
# Specify a list of updates.

# Format
set_clause_list =
    ','.{set_clause}
    ;

set_clause =
    multiple_column_assignment
  | set_target equals_operator update_source
    ;

set_target =
    update_target
  | mutated_set_clause
    ;

multiple_column_assignment =
    set_target_list equals_operator assigned_row
    ;

set_target_list =
    left_paren ','.{set_target} right_paren
    ;

assigned_row =
    contextually_typed_row_value_expression
    ;

update_target =
    object_column
  | object_column
        left_bracket_or_trigraph simple_value_specification right_bracket_or_trigraph
    ;

object_column =
    column_name
    ;

mutated_set_clause =
    mutated_target period method_name
    ;

mutated_target =
    object_column
  | mutated_set_clause
    ;

update_source =
    value_expression
  | contextually_typed_value_specification
    ;

# 14.16 temporary_table_declaration

# Function
# Declare a declared local temporary table.

# Format
temporary_table_declaration =
    'DECLARE' 'LOCAL' 'TEMPORARY' 'TABLE' table_name table_element_list
        ['ON' 'COMMIT' table_commit_action 'ROWS']
    ;

# 14.17 free_locator_statement

# Function
# Remove the association between a locator variable and the value that is
# represented by that locator.

# Format
free_locator_statement =
    'FREE' 'LOCATOR' ','.{locator_reference}
    ;

locator_reference =
    host_parameter_name
  | embedded_variable_name
  | dynamic_parameter_specification
    ;

# 14.18 hold_locator_statement

# Function
# Mark a locator variable as being holdable.

# Format
hold_locator_statement =
    'HOLD' 'LOCATOR' ','.{locator_reference}
    ;

# 16 Control statements

# 16.1 call_statement

# This Subclause is modified by Subclause 11.22, call_statement, in
# 'ISO'/'IEC' 9075-10.

# Function
# Invoke an SQL-invoked routine.

# Format
call_statement =
    'CALL' routine_invocation
    ;

# 16.2 return_statement

# Function
# Return a value from an SQL routine that is an SQL-invoked function.

# Format
return_statement =
    'RETURN' return_value
    ;

return_value =
    value_expression
  | 'NULL'
    ;

# 17 Transaction management

# 17.1 start_transaction_statement

# Function
# Start an SQL-transaction and set its characteristics.

# Format
start_transaction_statement =
    'START' 'TRANSACTION' [transaction_characteristics]
    ;

# 17.2 set_transaction_statement

# Function
# Set the characteristics of the next SQL-transaction for the SQL-agent.
# NOTE 522  This statement has no effect on any SQL-transactions subsequent to
# the next SQL-transaction.

# Format
set_transaction_statement =
    'SET' ['LOCAL'] 'TRANSACTION' transaction_characteristics
    ;

# 17.3 transaction_characteristics

# Function
# Specify transaction characteristics.

# Format
transaction_characteristics =
    [','.{transaction_mode}]
    ;

transaction_mode =
    isolation_level
  | transaction_access_mode
  | diagnostics_size
    ;

transaction_access_mode =
    'READ' 'ONLY'
  | 'READ' 'WRITE'
    ;

isolation_level =
    'ISOLATION' 'LEVEL' level_of_isolation
    ;

level_of_isolation =
    'READ' 'UNCOMMITTED'
  | 'READ' 'COMMITTED'
  | 'REPEATABLE' 'READ'
  | 'SERIALIZABLE'
    ;

diagnostics_size =
    'DIAGNOSTICS' 'SIZE' number_of_conditions
    ;

number_of_conditions =
    simple_value_specification
    ;

# 17.4 set_constraints_mode_statement

# Function
# If an SQL-transaction is currently active, then set the constraint mode for
# that SQL-transaction in the current SQL-session. If no SQL-transaction is
# currently active, then set the constraint mode for the next SQL-transaction
# in the current SQL-session for the SQL-agent.
# NOTE 524  This statement has no effect on any SQL-transactions subsequent
# to this SQL-transaction.

# Format
set_constraints_mode_statement =
    'SET' 'CONSTRAINTS' constraint_name_list
        ('DEFERRED' | 'IMMEDIATE')
    ;

constraint_name_list =
    'ALL'
  | ','.{constraint_name}
    ;

# 17.5 savepoint_statement

# Function
# Establish a savepoint.

# Format
savepoint_statement =
    'SAVEPOINT' savepoint_specifier
    ;

savepoint_specifier =
    savepoint_name
    ;

# 17.6 release_savepoint_statement

# Function
# Destroy a savepoint.

# Format
release_savepoint_statement =
    'RELEASE' 'SAVEPOINT' savepoint_specifier
    ;

# 17.7 commit_statement

# Function
# Terminate the current SQL-transaction with commit.

# Format
commit_statement =
    'COMMIT' ['WORK'] ['AND' ['NO'] 'CHAIN']
    ;

# 17.8 rollback_statement

# Function
# Terminate the current SQL-transaction with rollback, or rollback all actions
# affecting SQL-data and/or schemas since the establishment of a savepoint.

# Format
rollback_statement =
    'ROLLBACK' ['WORK'] ['AND' ['NO'] 'CHAIN'] [savepoint_clause]
    ;

savepoint_clause =
    'TO' 'SAVEPOINT' savepoint_specifier
    ;

# 18 Connection management

# 18.1 connect_statement

# Function
# Establish an SQL-session.

# Format
connect_statement =
    'CONNECT' 'TO' connection_target
    ;

connection_target =
    sql_server_name ['AS' connection_name] ['USER' connection_user_name]
  | 'DEFAULT'
    ;

# 18.2 set_connection_statement

# Function
# Select an SQL-connection from the available SQL-connections.

# Format
set_connection_statement =
    'SET' 'CONNECTION' connection_object
    ;

connection_object =
    'DEFAULT'
  | connection_name
    ;

# 18.3 disconnect_statement

# Function
# Terminate an SQL-connection.

# Format
disconnect_statement =
    'DISCONNECT' disconnect_object
    ;

disconnect_object =
    connection_object
  | 'ALL'
  | 'CURRENT'
    ;

# 19 Session management

# 19.1 set_session_characteristics_statement

# Function
# Set one or more characteristics for the current SQL-session.

# Format
set_session_characteristics_statement =
    'SET' 'SESSION' 'CHARACTERISTICS' 'AS' session_characteristic_list
    ;

session_characteristic_list =
    ','.{session_characteristic}
    ;

session_characteristic =
    session_transaction_characteristics
    ;

session_transaction_characteristics =
    'TRANSACTION' ','.{transaction_mode}
    ;

# 19.2 set_session_user_identifier_statement

# Function
# Set the SQL-session user identifier and the current user identifier of the
# current SQL-session context.

# Format
set_session_user_identifier_statement =
    'SET' 'SESSION' 'AUTHORIZATION' value_specification
    ;

# 19.3 set_role_statement

# Function
# Set the SQL-session role name and the current role name for the current
# SQL-session context.

# Format
set_role_statement =
    'SET' 'ROLE' role_specification
    ;

role_specification =
    value_specification
  | 'NONE'
    ;

# 19.4 set_local_time_zone_statement

# Function
# Set the current default time zone displacement for the current SQL-session.

# Format
set_local_time_zone_statement =
    'SET' 'TIME' 'ZONE' set_time_zone_value
    ;

set_time_zone_value =
    interval_value_expression
  | 'LOCAL'
    ;

# 19.5 set_catalog_statement

# Function
# Set the default catalog name for unqualified schema_names in
# preparable_statements that are prepared in the current SQL-session by an
# execute_immediate_statement or a prepare_statement and in
# direct_sql_statements that are invoked directly.

# Format
set_catalog_statement =
    'SET' catalog_name_characteristic
    ;

catalog_name_characteristic =
    'CATALOG' value_specification
    ;

# 19.6 set_schema_statement

# Function
# Set the default schema name for unqualified schema_qualified_names in
# preparable_statements that are prepared in the current SQL-session by an
# execute_immediate_statement or a prepare_statement and in
# direct_sql_statements that are invoked directly.

# Format
set_schema_statement =
    'SET' schema_name_characteristic
    ;

schema_name_characteristic =
    'SCHEMA' value_specification
    ;

# 19.7 set_names_statement

# Function
# Set the default character set name for character_string_literals in
# preparable_statements that are prepared in the current SQL-session by an
# execute_immediate_statement or a prepare_statement and in
# direct_sql_statements that are invoked directly.

# Format
set_names_statement =
    'SET' character_set_name_characteristic
    ;

character_set_name_characteristic =
    'NAMES' value_specification
    ;

# 19.8 set_path_statement

# Function
# Set the SQL-path used to determine the subject routine of routine_invocations
# with unqualified routine_names in preparable_statements that are prepared in
# the current SQL-session by an execute_immediate_statement or a
# prepare_statement and in direct_sql_statements that are invoked directly.
# The SQL-path remains the current SQL-path of the SQL-session until another
# SQL-path is successfully set.

# Format
set_path_statement =
    'SET' sql_path_characteristic
    ;

sql_path_characteristic =
    'PATH' value_specification
    ;

# 19.9 set_transform_group_statement

# Function
# Set the group name that identifies the group of transform functions for
# mapping values of user-defined types to predefined data types.

# Format
set_transform_group_statement =
    'SET' transform_group_characteristic
    ;

transform_group_characteristic =
    'DEFAULT' 'TRANSFORM' 'GROUP' value_specification
  | 'TRANSFORM' 'GROUP' 'FOR' 'TYPE' path_resolved_user_defined_type_name value_specification
    ;

# 20 Dynamic SQL

# 20.2 allocate_descriptor_statement

# Function
# Allocate an SQL descriptor area.

# Format
allocate_descriptor_statement =
    'ALLOCATE' ['SQL'] 'DESCRIPTOR' descriptor_name ['WITH' 'MAX' occurrences]
    ;

occurrences =
    simple_value_specification
    ;

# 20.3 deallocate_descriptor_statement

# Function
# Deallocate an SQL descriptor area.

# Format
deallocate_descriptor_statement =
    'DEALLOCATE' ['SQL'] 'DESCRIPTOR' descriptor_name
    ;

# 20.4 get_descriptor_statement

# Function
# Get information from an SQL descriptor area.

# Format
get_descriptor_statement =
    'GET' ['SQL'] 'DESCRIPTOR' descriptor_name get_descriptor_information
    ;

get_descriptor_information =
    ','.{get_header_information}
  | 'VALUE' item_number ','.{get_item_information}
    ;

get_header_information =
    simple_target_specification_1 equals_operator header_item_name
    ;

header_item_name =
    'COUNT'
  | 'KEY_TYPE'
  | 'DYNAMIC_FUNCTION'
  | 'DYNAMIC_FUNCTION_CODE'
  | 'TOP_LEVEL_COUNT'
    ;

get_item_information =
    simple_target_specification_2 equals_operator descriptor_item_name
    ;

item_number =
    simple_value_specification
    ;

simple_target_specification_1 =
    simple_target_specification
    ;

simple_target_specification_2 =
    simple_target_specification
    ;

descriptor_item_name =
    'CARDINALITY'
  | 'CHARACTER_SET_CATALOG'
  | 'CHARACTER_SET_NAME'
  | 'CHARACTER_SET_SCHEMA'
  | 'COLLATION_CATALOG'
  | 'COLLATION_NAME'
  | 'COLLATION_SCHEMA'
  | 'DATA'
  | 'DATETIME_INTERVAL_CODE'
  | 'DATETIME_INTERVAL_PRECISION'
  | 'DEGREE'
  | 'INDICATOR'
  | 'KEY_MEMBER'
  | 'LENGTH'
  | 'LEVEL'
  | 'NAME'
  | 'NULLABLE'
  | 'OCTET_LENGTH'
  | 'PARAMETER_MODE'
  | 'PARAMETER_ORDINAL_POSITION'
  | 'PARAMETER_SPECIFIC_CATALOG'
  | 'PARAMETER_SPECIFIC_NAME'
  | 'PARAMETER_SPECIFIC_SCHEMA'
  | 'PRECISION'
  | 'RETURNED_CARDINALITY'
  | 'RETURNED_LENGTH'
  | 'RETURNED_OCTET_LENGTH'
  | 'SCALE'
  | 'SCOPE_CATALOG'
  | 'SCOPE_NAME'
  | 'SCOPE_SCHEMA'
  | 'TYPE'
  | 'UNNAMED'
  | 'USER_DEFINED_TYPE_CATALOG'
  | 'USER_DEFINED_TYPE_NAME'
  | 'USER_DEFINED_TYPE_SCHEMA'
  | 'USER_DEFINED_TYPE_CODE'
    ;

# 20.5 set_descriptor_statement

# Function
# Set information in an SQL descriptor area.

# Format
set_descriptor_statement =
    'SET' ['SQL'] 'DESCRIPTOR' descriptor_name set_descriptor_information
    ;

set_descriptor_information =
    ','.{set_header_information}
  | 'VALUE' item_number ','.{set_item_information}
    ;

set_header_information =
    header_item_name equals_operator simple_value_specification_1
    ;

set_item_information =
    descriptor_item_name equals_operator simple_value_specification_2
    ;

simple_value_specification_1 =
    simple_value_specification
    ;

simple_value_specification_2 =
    simple_value_specification
    ;

# 20.6 prepare_statement

# Function
# Prepare a statement for execution.

# Format
prepare_statement =
    'PREPARE' sql_statement_name [attributes_specification]
        'FROM' sql_statement_variable
    ;

attributes_specification =
    'ATTRIBUTES' attributes_variable
    ;

attributes_variable =
    simple_value_specification
    ;

sql_statement_variable =
    simple_value_specification
    ;

preparable_statement =
    preparable_sql_data_statement
  | preparable_sql_schema_statement
  | preparable_sql_transaction_statement
  | preparable_sql_control_statement
  | preparable_sql_session_statement
  | preparable_implementation_defined_statement
    ;

preparable_sql_data_statement =
    delete_statement_searched
  | dynamic_single_row_select_statement
  | insert_statement
  | dynamic_select_statement
  | update_statement_searched
  | truncate_table_statement
  | merge_statement
  | preparable_dynamic_delete_statement_positioned
  | preparable_dynamic_update_statement_positioned
  | hold_locator_statement
  | free_locator_statement
    ;

preparable_sql_schema_statement =
    sql_schema_statement
    ;

preparable_sql_transaction_statement =
    sql_transaction_statement
    ;

preparable_sql_control_statement =
    sql_control_statement
    ;

preparable_sql_session_statement =
    sql_session_statement
    ;

dynamic_select_statement =
    cursor_specification
    ;

# SEE_SYNTAX_RULES
preparable_implementation_defined_statement =
    '# SEE_SYNTAX_RULES'
    ;

# 20.7 cursor_attributes

# Function
# Specify a list of cursor attributes.

# Format
cursor_attributes =
    {cursor_attribute}+
    ;

cursor_attribute =
    cursor_sensitivity
  | cursor_scrollability
  | cursor_holdability
  | cursor_returnability
    ;

# 20.8 deallocate_prepared_statement

# Function
# Deallocate SQL-statements that have been prepared with a prepare_statement.

# Format
deallocate_prepared_statement =
    'DEALLOCATE' 'PREPARE' sql_statement_name
    ;

# 20.9 describe_statement

# This Subclause is modified by Subclause 17.4, describe_statement, in
# 'ISO'/'IEC' 9075-9.

# Function
# Obtain information about the select_list columns or
# dynamic_parameter_specifications contained in a prepared statement or about
# the columns of the result set associated with a cursor.

# Format
describe_statement =
    describe_input_statement
  | describe_output_statement
    ;

describe_input_statement =
    'DESCRIBE' 'INPUT' sql_statement_name using_descriptor
        [nesting_option]
    ;

describe_output_statement =
    'DESCRIBE' ['OUTPUT'] described_object using_descriptor
        [nesting_option]
    ;

nesting_option =
    'WITH' 'NESTING'
  | 'WITHOUT' 'NESTING'
    ;

using_descriptor =
    'USING' ['SQL'] 'DESCRIPTOR' descriptor_name
    ;

described_object =
    sql_statement_name
  | 'CURSOR' cursor_name 'STRUCTURE'
    ;

# 20.10 input_using_clause

# Function
# Supply input values for an sql_dynamic_statement.

# Format
input_using_clause =
    using_arguments
  | using_input_descriptor
    ;

using_arguments =
    'USING' ','.{using_argument}
    ;

using_argument =
    general_value_specification
    ;

using_input_descriptor =
    using_descriptor
    ;

# 20.11 output_using_clause

# Function
# Supply output variables for an sql_dynamic_statement.

# Format
output_using_clause =
    into_arguments
  | into_descriptor
    ;

into_arguments =
    'INTO' ','.{into_argument}
    ;

into_argument =
    target_specification
    ;

into_descriptor =
    'INTO' ['SQL'] 'DESCRIPTOR' descriptor_name
    ;

# 20.12 execute_statement

# Function
# Associate input SQL parameters and output targets with a prepared statement
# and execute the statement.

# Format
execute_statement =
    'EXECUTE' sql_statement_name [result_using_clause]
        [parameter_using_clause]
    ;

result_using_clause =
    output_using_clause
    ;

parameter_using_clause =
    input_using_clause
    ;

# 20.13 execute_immediate_statement

# Function
# Dynamically prepare and execute a preparable statement.

# Format
execute_immediate_statement =
    'EXECUTE' 'IMMEDIATE' sql_statement_variable
    ;

# 20.14 dynamic_declare_cursor

# Function
# Declare a declared dynamic cursor to be associated with a statement_name,
# which may in turn be associated with a cursor_specification.

# Format
dynamic_declare_cursor =
    'DECLARE' cursor_name
        cursor_properties
        'FOR' statement_name
    ;

# 20.15 allocate_extended_dynamic_cursor_statement

# Function
# Define a cursor based on a prepared statement for a cursor_specification.

# Format
allocate_extended_dynamic_cursor_statement =
    'ALLOCATE' extended_cursor_name
        cursor_properties
        'FOR' extended_statement_name
    ;

# 20.16 allocate_received_cursor_statement

# Function
# Assign a cursor to the result set sequence returned from an SQL-invoked
# procedure.

# Format
allocate_received_cursor_statement =
    'ALLOCATE' cursor_name
        ['CURSOR'] 'FOR' 'PROCEDURE' specific_routine_designator
    ;

# 20.17 dynamic_open_statement

# Function
# Associate input dynamic parameters with a cursor_specification and open the
# dynamic cursor.

# Format
dynamic_open_statement =
    'OPEN' dynamic_cursor_name [input_using_clause]
    ;

# 20.18 dynamic_fetch_statement

# Function
# Fetch a row for a dynamic cursor.

# Format
dynamic_fetch_statement =
    'FETCH' [[fetch_orientation] 'FROM'] dynamic_cursor_name
        output_using_clause
    ;

# 20.19 dynamic_single_row_select_statement

# Function
# Retrieve values from a dynamically-specified row of a table.

# Format
dynamic_single_row_select_statement =
    query_specification
    ;

# 20.20 dynamic_close_statement

# Function
# Close a dynamic cursor.

# Format
dynamic_close_statement =
    'CLOSE' dynamic_cursor_name
    ;

# 20.21 dynamic_delete_statement_positioned

# Function
# Delete a row of a table.

# Format
dynamic_delete_statement_positioned =
    'DELETE' 'FROM' target_table 'WHERE' 'CURRENT' 'OF' dynamic_cursor_name
    ;

# 20.22 dynamic_update_statement_positioned

# Function
# Update a row of a table.

# Format
dynamic_update_statement_positioned =
    'UPDATE' target_table 'SET' set_clause_list
        'WHERE' 'CURRENT' 'OF' dynamic_cursor_name
    ;

# 20.23 preparable_dynamic_delete_statement_positioned

# Function
# Delete a row of a table through a dynamic cursor.

# Format
preparable_dynamic_delete_statement_positioned =
    'DELETE' ['FROM' target_table]
        'WHERE' 'CURRENT' 'OF' preparable_dynamic_cursor_name
    ;

# 20.24 preparable_dynamic_cursor_name

# Function
# Specify the cursor of a preparable_dynamic_delete_statement_positioned or a
# preparable_dynamic_update_statement_positioned.

# Format
preparable_dynamic_cursor_name =
    [scope_option] cursor_name
    ;

# 20.25 preparable_dynamic_update_statement_positioned

# Function
# Update a row of a table through a dynamic cursor.

# Format
preparable_dynamic_update_statement_positioned =
    'UPDATE' [target_table] 'SET' set_clause_list
        'WHERE' 'CURRENT' 'OF' preparable_dynamic_cursor_name
    ;

# 21 Embedded SQL

# 21.1 embedded_sql_host_program

# Function
# Specify an embedded_sql_host_program.

# Format
embedded_sql_host_program =
    embedded_sql_ada_program
  | embedded_sql_c_program
  | embedded_sql_cobol_program
  | embedded_sql_fortran_program
  | embedded_sql_mumps_program
  | embedded_sql_pascal_program
  | embedded_sql_pl_i_program
    ;

embedded_sql_statement =
    sql_prefix statement_or_declaration [sql_terminator]
    ;

statement_or_declaration =
    declare_cursor
  | dynamic_declare_cursor
  | temporary_table_declaration
  | embedded_authorization_declaration
  | embedded_path_specification
  | embedded_transform_group_specification
  | embedded_collation_specification
  | embedded_exception_declaration
  | sql_procedure_statement
    ;

sql_prefix =
    'EXEC' 'SQL'
  | ampersand'SQL' left_paren
    ;

sql_terminator =
    'END-EXEC'
  | semicolon
  | right_paren
    ;

embedded_authorization_declaration =
    'DECLARE' embedded_authorization_clause
    ;

embedded_authorization_clause =
    'SCHEMA' schema_name
  | 'AUTHORIZATION' embedded_authorization_identifier
        ['FOR' 'STATIC' ('ONLY' | 'AND' 'DYNAMIC')]
  | 'SCHEMA' schema_name 'AUTHORIZATION' embedded_authorization_identifier
        ['FOR' 'STATIC' ('ONLY' | 'AND' 'DYNAMIC')]
    ;

embedded_authorization_identifier =
    module_authorization_identifier
    ;

embedded_path_specification =
    path_specification
    ;

embedded_transform_group_specification =
    transform_group_specification
    ;

embedded_collation_specification =
    module_collations
    ;

embedded_sql_declare_section =
    embedded_sql_begin_declare
        [embedded_character_set_declaration]
        [{host_variable_definition}+]
        embedded_sql_end_declare
  | embedded_sql_mumps_declare
    ;

embedded_character_set_declaration =
    'SQL' 'NAMES' 'ARE' character_set_specification
    ;

embedded_sql_begin_declare =
    sql_prefix 'BEGIN' 'DECLARE' 'SECTION' [sql_terminator]
    ;

embedded_sql_end_declare =
    sql_prefix 'END' 'DECLARE' 'SECTION' [sql_terminator]
    ;

embedded_sql_mumps_declare =
    sql_prefix
        'BEGIN' 'DECLARE' 'SECTION'
        [embedded_character_set_declaration]
        [{host_variable_definition}+]
        'END' 'DECLARE' 'SECTION'
        sql_terminator
    ;

host_variable_definition =
    ada_variable_definition
  | c_variable_definition
  | cobol_variable_definition
  | fortran_variable_definition
  | mumps_variable_definition
  | pascal_variable_definition
  | pl_i_variable_definition
    ;

embedded_variable_name =
    colon host_identifier
    ;

host_identifier =
    ada_host_identifier
  | c_host_identifier
  | cobol_host_identifier
  | fortran_host_identifier
  | mumps_host_identifier
  | pascal_host_identifier
  | pl_i_host_identifier
    ;

# 21.2 embedded_exception_declaration

# Function
# Specify the action to be taken when an SQL-statement causes a specific class
# of condition to be raised.

# Format
embedded_exception_declaration =
    'WHENEVER' condition condition_action
    ;

condition =
    sql_condition
    ;

sql_condition =
    major_category
  | 'SQLSTATE' (sqlstate_class_value [',' sqlstate_subclass_value])
  | 'CONSTRAINT' constraint_name
    ;

major_category =
    'SQLEXCEPTION'
  | 'SQLWARNING'
  | 'NOT' 'FOUND'
    ;

# SEE_SYNTAX_RULES
sqlstate_class_value =
    sqlstate_char sqlstate_char
    ;

# SEE_SYNTAX_RULES
sqlstate_subclass_value =
    sqlstate_char sqlstate_char sqlstate_char
    ;

sqlstate_char =
    simple_latin_letter
  | digit
    ;

condition_action =
    'CONTINUE'
  | go_to
    ;

go_to =
    ('GOTO' | 'GO' 'TO') goto_target
    ;

goto_target =
    host_label_identifier
  | unsigned_integer
  | host_pl_i_label_variable
    ;

# SEE_SYNTAX_RULES
host_label_identifier =
    '# SEE_SYNTAX_RULES'
    ;

# SEE_SYNTAX_RULES
host_pl_i_label_variable =
    '# SEE_SYNTAX_RULES'
    ;

# 21.3 embedded_sql_ada_program

# Function
# Specify an embedded_sql_ada_program.

# Format
# SEE_SYNTAX_RULES
embedded_sql_ada_program =
    '# SEE_SYNTAX_RULES'
    ;

ada_variable_definition =
    ','.{ada_host_identifier} colon
        ada_type_specification [ada_initial_value]
    ;

ada_initial_value =
    ada_assignment_operator {character_representation}+
    ;

ada_assignment_operator =
    colon equals_operator
    ;

# SEE_SYNTAX_RULES
ada_host_identifier =
    '# SEE_SYNTAX_RULES'
    ;

ada_type_specification =
    ada_qualified_type_specification
  | ada_unqualified_type_specification
  | ada_derived_type_specification
    ;

ada_qualified_type_specification =
    'Interfaces' '.' 'SQL' '.' 'CHAR'
        ['CHARACTER' 'SET' ['IS'] character_set_specification]
        left_paren '1' double_period character_length right_paren
  | 'Interfaces' '.' 'SQL' '.' 'SMALLINT'
  | 'Interfaces' '.' 'SQL' '.' 'INT'
  | 'Interfaces' '.' 'SQL' '.' 'BIGINT'
  | 'Interfaces' '.' 'SQL' '.' 'REAL'
  | 'Interfaces' '.' 'SQL' '.' 'DOUBLE_PRECISION'
  | 'Interfaces' '.' 'SQL' '.' 'BOOLEAN'
  | 'Interfaces' '.' 'SQL' '.' 'SQLSTATE_TYPE'
  | 'Interfaces' '.' 'SQL' '.' 'INDICATOR_TYPE'
    ;

ada_unqualified_type_specification =
    'CHAR' left_paren '1' double_period character_length right_paren
  | 'SMALLINT'
  | 'INT'
  | 'BIGINT'
  | 'REAL'
  | 'DOUBLE_PRECISION'
  | 'BOOLEAN'
  | 'SQLSTATE_TYPE'
  | 'INDICATOR_TYPE'
    ;

ada_derived_type_specification =
    ada_clob_variable
  | ada_clob_locator_variable
  | ada_binary_variable
  | ada_varbinary_variable
  | ada_blob_variable
  | ada_blob_locator_variable
  | ada_user_defined_type_variable
  | ada_user_defined_type_locator_variable
  | ada_ref_variable
  | ada_array_locator_variable
  | ada_multiset_locator_variable
    ;

ada_clob_variable =
    'SQL' 'TYPE' 'IS' 'CLOB' left_paren character_large_object_length right_paren
        ['CHARACTER' 'SET' ['IS'] character_set_specification]
    ;

ada_clob_locator_variable =
    'SQL' 'TYPE' 'IS' 'CLOB' 'AS' 'LOCATOR'
    ;

ada_binary_variable =
    'SQL' 'TYPE' 'IS' 'BINARY' left_paren length right_paren
    ;

ada_varbinary_variable =
    'SQL' 'TYPE' 'IS' 'VARBINARY' left_paren length right_paren
    ;

ada_blob_variable =
    'SQL' 'TYPE' 'IS' 'BLOB' left_paren large_object_length right_paren
    ;

ada_blob_locator_variable =
    'SQL' 'TYPE' 'IS' 'BLOB' 'AS' 'LOCATOR'
    ;

ada_user_defined_type_variable =
    'SQL' 'TYPE' 'IS' path_resolved_user_defined_type_name 'AS' predefined_type
    ;

ada_user_defined_type_locator_variable =
    'SQL' 'TYPE' 'IS' path_resolved_user_defined_type_name 'AS' 'LOCATOR'
    ;

ada_ref_variable =
    'SQL' 'TYPE' 'IS' reference_type
    ;

ada_array_locator_variable =
    'SQL' 'TYPE' 'IS' array_type 'AS' 'LOCATOR'
    ;

ada_multiset_locator_variable =
    'SQL' 'TYPE' 'IS' multiset_type 'AS' 'LOCATOR'
    ;

# 21.4 embedded_sql_c_program

# Function
# Specify an embedded_sql_c_program.

# Format
# SEE_SYNTAX_RULES
embedded_sql_c_program =
    '# SEE_SYNTAX_RULES'
    ;

c_variable_definition =
    [c_storage_class] [c_class_modifier]
        c_variable_specification semicolon
    ;

c_variable_specification =
    c_numeric_variable
  | c_character_variable
  | c_derived_variable
    ;

c_storage_class =
    'auto'
  | 'extern'
  | 'static'
    ;

c_class_modifier =
    'const'
  | 'volatile'
    ;

c_numeric_variable =
    ('long' 'long' | 'long' | 'short' | 'float' | 'double')
        ','.{c_host_identifier [c_initial_value]}
    ;

c_character_variable =
    c_character_type ['CHARACTER' 'SET' ['IS'] character_set_specification]
        ','.{c_host_identifier c_array_specification [c_initial_value]}
    ;

c_character_type =
    'char'
  | 'unsigned' 'char'
  | 'unsigned' 'short'
    ;

c_array_specification =
    left_bracket character_length right_bracket
    ;

# SEE_SYNTAX_RULES
c_host_identifier =
    '# SEE_SYNTAX_RULES'
    ;

c_derived_variable =
    c_varchar_variable
  | c_nchar_variable
  | c_nchar_varying_variable
  | c_clob_variable
  | c_nclob_variable
  | c_binary_variable
  | c_varbinary_variable
  | c_blob_variable
  | c_user_defined_type_variable
  | c_clob_locator_variable
  | c_blob_locator_variable
  | c_array_locator_variable
  | c_multiset_locator_variable
  | c_user_defined_type_locator_variable
  | c_ref_variable
    ;

c_varchar_variable =
    'VARCHAR' ['CHARACTER' 'SET' ['IS'] character_set_specification]
        ','.{c_host_identifier c_array_specification [c_initial_value]}
    ;

c_nchar_variable =
    'NCHAR' ['CHARACTER' 'SET' ['IS'] character_set_specification]
        ','.{c_host_identifier c_array_specification [c_initial_value]}
    ;

c_nchar_varying_variable =
    'NCHAR' 'VARYING' ['CHARACTER' 'SET' ['IS'] character_set_specification]
        ','.{c_host_identifier c_array_specification [c_initial_value]}
    ;

c_clob_variable =
    'SQL' 'TYPE' 'IS' 'CLOB' left_paren character_large_object_length right_paren
        ['CHARACTER' 'SET' ['IS'] character_set_specification]
        ','.{c_host_identifier [c_initial_value]}
    ;

c_nclob_variable =
    'SQL' 'TYPE' 'IS' 'NCLOB' left_paren character_large_object_length right_paren
        ['CHARACTER' 'SET' ['IS'] character_set_specification]
        ','.{c_host_identifier [c_initial_value]}
    ;

c_user_defined_type_variable =
    'SQL' 'TYPE' 'IS' path_resolved_user_defined_type_name 'AS' predefined_type
        ','.{c_host_identifier [c_initial_value]}
    ;

c_binary_variable =
    'SQL' 'TYPE' 'IS' 'BINARY' left_paren length right_paren
        ','.{c_host_identifier [c_initial_value]}
    ;

c_varbinary_variable =
    'SQL' 'TYPE' 'IS' 'VARBINARY' left_paren length right_paren
        ','.{c_host_identifier [c_initial_value]}
    ;

c_blob_variable =
    'SQL' 'TYPE' 'IS' 'BLOB' left_paren large_object_length right_paren
        ','.{c_host_identifier [c_initial_value]}
    ;

c_clob_locator_variable =
    'SQL' 'TYPE' 'IS' 'CLOB' 'AS' 'LOCATOR'
        ','.{c_host_identifier [c_initial_value]}
    ;

c_blob_locator_variable =
    'SQL' 'TYPE' 'IS' 'BLOB' 'AS' 'LOCATOR'
        ','.{c_host_identifier [c_initial_value]}
    ;

c_array_locator_variable =
    'SQL' 'TYPE' 'IS' array_type 'AS' 'LOCATOR'
        ','.{c_host_identifier [c_initial_value]}
    ;

c_multiset_locator_variable =
    'SQL' 'TYPE' 'IS' multiset_type 'AS' 'LOCATOR'
        ','.{c_host_identifier [c_initial_value]}
    ;

c_user_defined_type_locator_variable =
    'SQL' 'TYPE' 'IS' path_resolved_user_defined_type_name 'AS' 'LOCATOR'
        ','.{c_host_identifier [c_initial_value]}
    ;

c_ref_variable =
    'SQL' 'TYPE' 'IS' reference_type ','.{c_host_identifier [c_initial_value]}
    ;

c_initial_value =
    equals_operator {character_representation}+
    ;

# 21.5 embedded_sql_cobol_program

# Function
# Specify an embedded_sql_cobol_program.

# Format
# SEE_SYNTAX_RULES
embedded_sql_cobol_program =
    '# SEE_SYNTAX_RULES'
    ;

cobol_variable_definition =
    ('01' | '77') cobol_host_identifier
        cobol_type_specification [{character_representation}+] period
    ;

# SEE_SYNTAX_RULES
cobol_host_identifier =
    '# SEE_SYNTAX_RULES'
    ;

cobol_type_specification =
    cobol_character_type
  | cobol_national_character_type
  | cobol_numeric_type
  | cobol_integer_type
  | cobol_derived_type_specification
    ;

cobol_derived_type_specification =
    cobol_clob_variable
  | cobol_nclob_variable
  | cobol_binary_variable
  | cobol_blob_variable
  | cobol_user_defined_type_variable
  | cobol_clob_locator_variable
  | cobol_blob_locator_variable
  | cobol_array_locator_variable
  | cobol_multiset_locator_variable
  | cobol_user_defined_type_locator_variable
  | cobol_ref_variable
    ;

cobol_character_type =
    ['CHARACTER' 'SET' ['IS'] character_set_specification]
        ('PIC' | 'PICTURE') ['IS']
        {'X' [left_paren character_length right_paren]}+
    ;

cobol_national_character_type =
    ['CHARACTER' 'SET' ['IS'] character_set_specification]
        ('PIC' | 'PICTURE') ['IS']
        {'N' [left_paren character_length right_paren]}+
    ;

cobol_clob_variable =
    ['USAGE' ['IS']] 'SQL' 'TYPE' 'IS' 'CLOB'
        left_paren character_large_object_length right_paren
        ['CHARACTER' 'SET' ['IS'] character_set_specification]
    ;

cobol_nclob_variable =
    ['USAGE' ['IS']] 'SQL' 'TYPE' 'IS' 'NCLOB'
        left_paren character_large_object_length right_paren
        ['CHARACTER' 'SET' ['IS'] character_set_specification]
    ;

cobol_binary_variable =
    ['USAGE' ['IS']] 'SQL' 'TYPE' 'IS' 'BINARY'
        left_paren length right_paren
    ;

cobol_blob_variable =
    ['USAGE' ['IS']] 'SQL' 'TYPE' 'IS' 'BLOB'
        left_paren large_object_length right_paren
    ;

cobol_user_defined_type_variable =
    ['USAGE' ['IS']] 'SQL' 'TYPE' 'IS'
        path_resolved_user_defined_type_name
        'AS' predefined_type
    ;

cobol_clob_locator_variable =
    ['USAGE' ['IS']] 'SQL' 'TYPE' 'IS' 'CLOB' 'AS' 'LOCATOR'
    ;

cobol_blob_locator_variable =
    ['USAGE' ['IS']] 'SQL' 'TYPE' 'IS' 'BLOB' 'AS' 'LOCATOR'
    ;

cobol_array_locator_variable =
    ['USAGE' ['IS']] 'SQL' 'TYPE' 'IS'
        array_type 'AS' 'LOCATOR'
    ;

cobol_multiset_locator_variable =
    ['USAGE' ['IS']] 'SQL' 'TYPE' 'IS'
        multiset_type 'AS' 'LOCATOR'
    ;

cobol_user_defined_type_locator_variable =
    ['USAGE' ['IS']] 'SQL' 'TYPE' 'IS'
        path_resolved_user_defined_type_name 'AS' 'LOCATOR'
    ;

cobol_ref_variable =
    ['USAGE' ['IS']] 'SQL' 'TYPE' 'IS' reference_type
    ;

cobol_numeric_type =
    ('PIC' | 'PICTURE') ['IS'] 'S' cobol_nines_specification
        ['USAGE' ['IS']] 'DISPLAY' 'SIGN' 'LEADING' 'SEPARATE'
    ;

cobol_nines_specification =
    cobol_nines ['V' [cobol_nines]]
  | 'V' cobol_nines
    ;

cobol_integer_type =
    ('PIC' | 'PICTURE') ['IS'] 'S' cobol_nines
        ['USAGE' ['IS']] 'BINARY'
    ;

cobol_nines =
    {'9' [left_paren length right_paren]}+
    ;

# 21.6 embedded_sql_fortran_program

# Function
# Specify an embedded_sql_fortran_program.

# Format
# SEE_SYNTAX_RULES
embedded_sql_fortran_program =
    '# SEE_SYNTAX_RULES'
    ;

fortran_variable_definition =
    fortran_type_specification ','.{fortran_host_identifier}
    ;

# SEE_SYNTAX_RULES
fortran_host_identifier =
    '# SEE_SYNTAX_RULES'
    ;

fortran_type_specification =
    'CHARACTER' [asterisk character_length]
        ['CHARACTER' 'SET' ['IS'] character_set_specification]
  | 'CHARACTER' 'KIND' '=' 'n' [asterisk character_length]
        ['CHARACTER' 'SET' ['IS'] character_set_specification]
  | 'INTEGER'
  | 'REAL'
  | 'DOUBLE' 'PRECISION'
  | 'LOGICAL'
  | fortran_derived_type_specification
    ;

fortran_derived_type_specification =
    fortran_clob_variable
  | fortran_binary_variable
  | fortran_varbinary_variable
  | fortran_blob_variable
  | fortran_user_defined_type_variable
  | fortran_clob_locator_variable
  | fortran_blob_locator_variable
  | fortran_user_defined_type_locator_variable
  | fortran_array_locator_variable
  | fortran_multiset_locator_variable
  | fortran_ref_variable
    ;

fortran_clob_variable =
    'SQL' 'TYPE' 'IS' 'CLOB'
        left_paren character_large_object_length right_paren
        ['CHARACTER' 'SET' ['IS'] character_set_specification]
    ;

fortran_binary_variable =
    'SQL' 'TYPE' 'IS' 'BINARY' left_paren length right_paren
    ;

fortran_varbinary_variable =
    'SQL' 'TYPE' 'IS' 'VARBINARY' left_paren length right_paren
    ;

fortran_blob_variable =
    'SQL' 'TYPE' 'IS' 'BLOB' left_paren large_object_length right_paren
    ;

fortran_user_defined_type_variable =
    'SQL' 'TYPE' 'IS' path_resolved_user_defined_type_name 'AS' predefined_type
    ;

fortran_clob_locator_variable =
    'SQL' 'TYPE' 'IS' 'CLOB' 'AS' 'LOCATOR'
    ;

fortran_blob_locator_variable =
    'SQL' 'TYPE' 'IS' 'BLOB' 'AS' 'LOCATOR'
    ;

fortran_user_defined_type_locator_variable =
    'SQL' 'TYPE' 'IS' path_resolved_user_defined_type_name 'AS' 'LOCATOR'
    ;

fortran_array_locator_variable =
    'SQL' 'TYPE' 'IS' array_type 'AS' 'LOCATOR'
    ;

fortran_multiset_locator_variable =
    'SQL' 'TYPE' 'IS' multiset_type 'AS' 'LOCATOR'
    ;

fortran_ref_variable =
    'SQL' 'TYPE' 'IS' reference_type
    ;

# 21.7 embedded_sql_mumps_program

# Function
# Specify an embedded_sql_mumps_program.

# Format
# SEE_SYNTAX_RULES
embedded_sql_mumps_program =
    '# SEE_SYNTAX_RULES'
    ;

mumps_variable_definition =
    mumps_numeric_variable semicolon
  | mumps_character_variable semicolon
  | mumps_derived_type_specification mumps_host_identifier semicolon
    ;

mumps_character_variable =
    'VARCHAR' ','.{mumps_character_variable_specifier}
    ;

mumps_character_variable_specifier =
    mumps_host_identifier mumps_length_specification
        ['CHARACTER' 'SET' ['IS'] character_set_specification]
    ;

# SEE_SYNTAX_RULES
mumps_host_identifier =
    '# SEE_SYNTAX_RULES'
    ;

mumps_length_specification =
    left_paren character_length right_paren
    ;

mumps_numeric_variable =
    mumps_type_specification ','.{mumps_host_identifier}
    ;

mumps_type_specification =
    'INT'
  | 'DEC' [left_paren precision [comma scale] right_paren]
  | 'REAL'
    ;

mumps_derived_type_specification =
    mumps_user_defined_type_variable
  | mumps_clob_locator_variable
  | mumps_blob_locator_variable
  | mumps_user_defined_type_locator_variable
  | mumps_array_locator_variable
  | mumps_multiset_locator_variable
  | mumps_ref_variable
    ;

mumps_user_defined_type_variable =
    'SQL' 'TYPE' 'IS' path_resolved_user_defined_type_name
        'AS' predefined_type
    ;

mumps_clob_locator_variable =
    'SQL' 'TYPE' 'IS' 'CLOB' 'AS' 'LOCATOR'
    ;

mumps_blob_locator_variable =
    'SQL' 'TYPE' 'IS' 'BLOB' 'AS' 'LOCATOR'
    ;

mumps_user_defined_type_locator_variable =
    'SQL' 'TYPE' 'IS' path_resolved_user_defined_type_name 'AS' 'LOCATOR'
    ;

mumps_array_locator_variable =
    'SQL' 'TYPE' 'IS' array_type 'AS' 'LOCATOR'
    ;

mumps_multiset_locator_variable =
    'SQL' 'TYPE' 'IS' multiset_type 'AS' 'LOCATOR'
    ;

mumps_ref_variable =
    'SQL' 'TYPE' 'IS' reference_type
    ;

# 21.8 embedded_sql_pascal_program

# Function
# Specify an embedded_sql_pascal_program.

# Format
# SEE_SYNTAX_RULES
embedded_sql_pascal_program =
    '# SEE_SYNTAX_RULES'
    ;

pascal_variable_definition =
    ','.{pascal_host_identifier} colon
        pascal_type_specification semicolon
    ;

# SEE_SYNTAX_RULES
pascal_host_identifier =
    '# SEE_SYNTAX_RULES'
    ;

pascal_type_specification =
    'PACKED' 'ARRAY' left_bracket '1'
        double_period character_length right_bracket
        'OF' 'CHAR' ['CHARACTER' 'SET' ['IS'] character_set_specification]
  | 'INTEGER'
  | 'REAL'
  | 'CHAR' ['CHARACTER' 'SET' ['IS'] character_set_specification]
  | 'BOOLEAN'
  | pascal_derived_type_specification
    ;

pascal_derived_type_specification =
    pascal_clob_variable
  | pascal_binary_variable
  | pascal_blob_variable
  | pascal_user_defined_type_variable
  | pascal_clob_locator_variable
  | pascal_blob_locator_variable
  | pascal_user_defined_type_locator_variable
  | pascal_array_locator_variable
  | pascal_multiset_locator_variable
  | pascal_ref_variable
    ;

pascal_clob_variable =
    'SQL' 'TYPE' 'IS' 'CLOB'
        left_paren character_large_object_length right_paren
        ['CHARACTER' 'SET' ['IS'] character_set_specification]
    ;

pascal_binary_variable =
    'SQL' 'TYPE' 'IS' 'BINARY' left_paren length right_paren
    ;

pascal_blob_variable =
    'SQL' 'TYPE' 'IS' 'BLOB' left_paren large_object_length right_paren
    ;

pascal_clob_locator_variable =
    'SQL' 'TYPE' 'IS' 'CLOB' 'AS' 'LOCATOR'
    ;

pascal_user_defined_type_variable =
    'SQL' 'TYPE' 'IS' path_resolved_user_defined_type_name 'AS' predefined_type
    ;

pascal_blob_locator_variable =
    'SQL' 'TYPE' 'IS' 'BLOB' 'AS' 'LOCATOR'
    ;

pascal_user_defined_type_locator_variable =
    'SQL' 'TYPE' 'IS' path_resolved_user_defined_type_name 'AS' 'LOCATOR'
    ;

pascal_array_locator_variable =
    'SQL' 'TYPE' 'IS' array_type 'AS' 'LOCATOR'
    ;

pascal_multiset_locator_variable =
    'SQL' 'TYPE' 'IS' multiset_type 'AS' 'LOCATOR'
    ;

pascal_ref_variable =
    'SQL' 'TYPE' 'IS' reference_type
    ;

# 21.9 embedded_sql_pl_i_program

# Function
# Specify an embedded_sql_pl_i_program.

# Format
# SEE_SYNTAX_RULES
embedded_sql_pl_i_program =
    '# SEE_SYNTAX_RULES'
    ;

pl_i_variable_definition =
    ('DCL' | 'DECLARE') pl_i_type_specification [{character_representation}+] semicolon
  | (pl_i_host_identifier | left_paren ','.{pl_i_host_identifier} right_paren)
        pl_i_type_specification [{character_representation}+] semicolon
    ;

# SEE_SYNTAX_RULES
pl_i_host_identifier =
    '# SEE_SYNTAX_RULES'
    ;

pl_i_type_specification =
    ('CHAR' | 'CHARACTER') ['VARYING'] left_paren character_length right_paren
        ['CHARACTER' 'SET' ['IS'] character_set_specification]
  | pl_i_type_fixed_decimal left_paren precision [comma scale] right_paren
  | pl_i_type_fixed_binary [left_paren precision right_paren]
  | pl_i_type_float_binary left_paren precision right_paren
  | pl_i_derived_type_specification
    ;

pl_i_derived_type_specification =
    pl_i_clob_variable
  | pl_i_binary_variable
  | pl_i_varbinary_variable
  | pl_i_blob_variable
  | pl_i_user_defined_type_variable
  | pl_i_clob_locator_variable
  | pl_i_blob_locator_variable
  | pl_i_user_defined_type_locator_variable
  | pl_i_array_locator_variable
  | pl_i_multiset_locator_variable
  | pl_i_ref_variable
    ;

pl_i_clob_variable =
    'SQL' 'TYPE' 'IS' 'CLOB' left_paren character_large_object_length right_paren
        ['CHARACTER' 'SET' ['IS'] character_set_specification]
    ;

pl_i_binary_variable =
    'SQL' 'TYPE' 'IS' 'BINARY' left_paren length right_paren
    ;

pl_i_varbinary_variable =
    'SQL' 'TYPE' 'IS' 'VARBINARY' left_paren length right_paren
    ;

pl_i_blob_variable =
    'SQL' 'TYPE' 'IS' 'BLOB' left_paren large_object_length right_paren
    ;

pl_i_user_defined_type_variable =
    'SQL' 'TYPE' 'IS' path_resolved_user_defined_type_name 'AS' predefined_type
    ;

pl_i_clob_locator_variable =
    'SQL' 'TYPE' 'IS' 'CLOB' 'AS' 'LOCATOR'
    ;

pl_i_blob_locator_variable =
    'SQL' 'TYPE' 'IS' 'BLOB' 'AS' 'LOCATOR'
    ;

pl_i_user_defined_type_locator_variable =
    'SQL' 'TYPE' 'IS' path_resolved_user_defined_type_name 'AS' 'LOCATOR'
    ;

pl_i_array_locator_variable =
    'SQL' 'TYPE' 'IS' array_type 'AS' 'LOCATOR'
    ;

pl_i_multiset_locator_variable =
    'SQL' 'TYPE' 'IS' multiset_type 'AS' 'LOCATOR'
    ;

pl_i_ref_variable =
    'SQL' 'TYPE' 'IS' reference_type
    ;

pl_i_type_fixed_decimal =
    ('DEC' | 'DECIMAL') 'FIXED'
  | 'FIXED' ('DEC' | 'DECIMAL')
    ;

pl_i_type_fixed_binary =
    ('BIN' | 'BINARY') 'FIXED'
  | 'FIXED' ('BIN' | 'BINARY')
    ;

pl_i_type_float_binary =
    ('BIN' | 'BINARY') 'FLOAT'
  | 'FLOAT' ('BIN' | 'BINARY')
    ;

# 22 Direct invocation of SQL

# 22.1 direct_sql_statement

# Function
# Specify direct execution of SQL.

# Format
direct_sql_statement =
    ';'.{directly_executable_statement} [semicolon]
    ;

directly_executable_statement =
    direct_sql_data_statement
  | sql_schema_statement
  | sql_transaction_statement
  | sql_connection_statement
  | sql_session_statement
  | direct_implementation_defined_statement
    ;

direct_sql_data_statement =
    delete_statement_searched
  | direct_select_statement_multiple_rows
  | insert_statement
  | update_statement_searched
  | truncate_table_statement
  | merge_statement
  | temporary_table_declaration
    ;

# SEE_SYNTAX_RULES
direct_implementation_defined_statement =
    '# SEE_SYNTAX_RULES'
    ;

# 22.2 direct_select_statement_multiple_rows

# Function
# Specify a statement to retrieve multiple rows from a specified table.

# Format
direct_select_statement_multiple_rows =
    cursor_specification
    ;

# 23 Diagnostics management

# 23.1 get_diagnostics_statement

# Function
# Get exception or completion condition information from a diagnostics area.

# Format
get_diagnostics_statement =
    'GET' 'DIAGNOSTICS' sql_diagnostics_information
    ;

sql_diagnostics_information =
    statement_information
  | condition_information
  | all_information
    ;

statement_information =
    ','.{statement_information_item}
    ;

statement_information_item =
    simple_target_specification equals_operator statement_information_item_name
    ;

statement_information_item_name =
    'NUMBER'
  | 'MORE'
  | 'COMMAND_FUNCTION'
  | 'COMMAND_FUNCTION_CODE'
  | 'DYNAMIC_FUNCTION'
  | 'DYNAMIC_FUNCTION_CODE'
  | 'ROW_COUNT'
  | 'TRANSACTIONS_COMMITTED'
  | 'TRANSACTIONS_ROLLED_BACK'
  | 'TRANSACTION_ACTIVE'
    ;

condition_information =
    'CONDITION' condition_number ','.{condition_information_item}
    ;

condition_information_item =
    simple_target_specification equals_operator condition_information_item_name
    ;

condition_information_item_name =
    'CATALOG_NAME'
  | 'CLASS_ORIGIN'
  | 'COLUMN_NAME'
  | 'CONDITION_NUMBER'
  | 'CONNECTION_NAME'
  | 'CONSTRAINT_CATALOG'
  | 'CONSTRAINT_NAME'
  | 'CONSTRAINT_SCHEMA'
  | 'CURSOR_NAME'
  | 'MESSAGE_LENGTH'
  | 'MESSAGE_OCTET_LENGTH'
  | 'MESSAGE_TEXT'
  | 'PARAMETER_MODE'
  | 'PARAMETER_NAME'
  | 'PARAMETER_ORDINAL_POSITION'
  | 'RETURNED_SQLSTATE'
  | 'ROUTINE_CATALOG'
  | 'ROUTINE_NAME'
  | 'ROUTINE_SCHEMA'
  | 'SCHEMA_NAME'
  | 'SERVER_NAME'
  | 'SPECIFIC_NAME'
  | 'SUBCLASS_ORIGIN'
  | 'TABLE_NAME'
  | 'TRIGGER_CATALOG'
  | 'TRIGGER_NAME'
  | 'TRIGGER_SCHEMA'
    ;

all_information =
    all_info_target equals_operator 'ALL' [all_qualifier]
    ;

all_info_target =
    simple_target_specification
    ;

all_qualifier =
    'STATEMENT'
  | 'CONDITION' [condition_number]
    ;

condition_number =
    simple_value_specification
    ;
